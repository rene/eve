From ce257c0a441aa18d69a92d57b243b66699400c59 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ren=C3=AA=20de=20Souza=20Pinto?= <rene@renesp.com.br>
Date: Thu, 19 Jan 2023 13:37:22 +0100
Subject: [PATCH 26/40] drivers: clk: imx: Update clock driver for i.MX8MP
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This commit squashes a series of commits taken from
git://git.phytec.de/linux-imx.

The following original commits were cherry-picked:

c9f0d17833195 MLK-25441 clk: imx8mp: fix ISP clocks in mediamix
497aacca3980c clk: imx: Add blk_ctrl combo driver
e44810f405ef4 dt-bindings: clock: imx8mp: Add media blk_ctrl clock IDs
2a2438d319d94 dt-bindings: clock: imx8mp: Add ids for the audio shared gate
7f9b34c327311 dt-bindings: clocks: imx8mp: Rename audiomix ids clocks to audio_blk_ctrl
35918e18b7fe1 MLK-23751 clk: imx: Add audio PLL debug fs for K-divider monitor control
6bfe967f1f90c dt-bindings: clock: imx8mp: Add ids for the audio shared gate
251470e8d3f66 dt-bindings: clocks: imx8mp: Rename audiomix ids clocks to audio_blk_ctrl
d3d0225016e57 dt-bindings: reset: imx8mp: Add hdmi blk_ctrl reset IDs
5df2f295cdcc7 dt-bindings: reset: imx8mp: Add media blk_ctrl reset IDs
5b9d9596505e2 dt-bindings: reset: imx8mp: Add audio blk_ctrl reset IDs
c9f0d17833195 MLK-25441 clk: imx8mp: fix ISP clocks in mediamix
ec8d42ae70550 MA-17597 clk: imx8mp: remove __init in imx_clk_init_on
3926aa7c4b7dc LF-3016-1 clk: imx8mp: check hws in pll_debug_init
6bc10085f4bb4 clk: imx: blk_ctrl: Fix runtime PM get_sync/put balancing for resets
70c20f7041a70 clk: imx: blk_ctrl: Use the imx_ccm_lock to protect on runtime PM callbacks
1d6f7af01f0e0 MLK-24980 clk: imx8mp: Add audio pll debug monitor on imx8mp
007b0655a05a5 LF-2601 clk: imx8mp: add missed imx_clk_init_on()
1ca8f1f98fe8c clk: imx: clk-imx8mp: fix PDM clocks
8f8b8590563df clk: imx: add SAI PLL frequencies
da8fbdd77a077 LF-2368 clk: imx: Remove the sys pll divider gates on imx8mp/mq
f78563d9f86c6 LF-2366 clk: imx: Add m4 enable check for imx8mp
b99e89a80f20a clk: imx8mp: change the 'nand_usdhc_bus' clock to non-critical
be6b11270ae6f LF-2231: clk: imx: use SET_NOIRQ_SYSTEM_SLEEP_PM_OPS
2d508e6e0d5d4 clk: imx8mp: Add media blk_ctrl clocks and resets
c219af050718e clk: imx8mp: Add hdmi blk_ctrl clocks and resets
858be6440b2d0 clk: imx8mp: Add audio blk_ctrl clocks and resets
497aacca3980c clk: imx: Add blk_ctrl combo driver
5a15bda095516 clk: imx8mp: Add audio shared gate
c6f4b139225cd MLK-23252-2 clk: imx8mp: Add LDB root clock
0fdf04326a9a1 MLK-23252-1 clk: imx8mp: Add DISP2 pixel clock

Signed-off-by: RenÃª de Souza Pinto <rene@renesp.com.br>
---
 arch/arm64/boot/dts/freescale/imx8mp.dtsi | 806 ++++++++++++++++++++++
 drivers/clk/imx/Makefile                  |   2 +-
 drivers/clk/imx/clk-blk-ctrl.c            | 341 +++++++++
 drivers/clk/imx/clk-blk-ctrl.h            |  81 +++
 drivers/clk/imx/clk-imx7d.c               |   2 +-
 drivers/clk/imx/clk-imx8mm.c              |  78 ++-
 drivers/clk/imx/clk-imx8mn.c              |   2 +-
 drivers/clk/imx/clk-imx8mp.c              | 462 +++++++++++--
 drivers/clk/imx/clk-imx8mq.c              |   2 +-
 drivers/clk/imx/clk-pll14xx.c             |  20 +
 drivers/clk/imx/clk.h                     |   3 +
 include/dt-bindings/clock/imx8mp-clock.h  | 325 +++++++--
 include/dt-bindings/reset/imx8mp-reset.h  |  48 +-
 13 files changed, 2064 insertions(+), 108 deletions(-)
 create mode 100644 drivers/clk/imx/clk-blk-ctrl.c
 create mode 100644 drivers/clk/imx/clk-blk-ctrl.h

diff --git a/arch/arm64/boot/dts/freescale/imx8mp.dtsi b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
index acee71ca32d8..a0216aa9ca79 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
@@ -733,6 +733,812 @@ fec: ethernet@30be0000 {
 				assigned-clock-rates = <0>, <100000000>, <125000000>, <0>;
 				fsl,num-tx-queues = <3>;
 				fsl,num-rx-queues = <3>;
+				nvmem-cells = <&eth_mac1>;
+				nvmem-cell-names = "mac-address";
+				nvmem_macaddr_swap;
+				fsl,stop-mode = <&gpr 0x10 3>;
+				fsl,wakeup_irq = <2>;
+				status = "disabled";
+			};
+
+			eqos: ethernet@30bf0000 {
+				compatible = "nxp,imx8mp-dwmac-eqos", "snps,dwmac-5.10a";
+				reg = <0x30bf0000 0x10000>;
+				interrupts = <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "eth_wake_irq", "macirq";
+				clocks = <&clk IMX8MP_CLK_ENET_QOS_ROOT>,
+					 <&clk IMX8MP_CLK_QOS_ENET_ROOT>,
+					 <&clk IMX8MP_CLK_ENET_QOS_TIMER>,
+					 <&clk IMX8MP_CLK_ENET_QOS>;
+				clock-names = "stmmaceth", "pclk", "ptp_ref", "tx";
+				assigned-clocks = <&clk IMX8MP_CLK_ENET_AXI>,
+						  <&clk IMX8MP_CLK_ENET_QOS_TIMER>,
+						  <&clk IMX8MP_CLK_ENET_QOS>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_266M>,
+							 <&clk IMX8MP_SYS_PLL2_100M>,
+							 <&clk IMX8MP_SYS_PLL2_125M>;
+				assigned-clock-rates = <0>, <100000000>, <125000000>;
+				nvmem-cells = <&eth_mac2>;
+				nvmem-cell-names = "mac-address";
+				nvmem_macaddr_swap;
+				intf_mode = <&gpr 0x4>;
+				status = "disabled";
+			};
+		};
+
+		aips4: bus@32c00000 {
+			compatible = "simple-bus";
+			reg = <0x32c00000 0x400000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			mipi_dsi: mipi_dsi@32e60000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-mipi-dsim";
+				reg = <0x32e60000 0x10000>;
+				clocks = <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_PCLK>,
+					 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_CLKREF>;
+				clock-names = "cfg", "pll-ref";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_MIPI_PHY1_REF>;
+				assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+				assigned-clock-rates = <12000000>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+				power-domains = <&mipi_phy1_pd>;
+				status = "disabled";
+
+				port@0 {
+					dsim_from_lcdif: endpoint {
+						remote-endpoint = <&lcdif_to_dsim>;
+					};
+				};
+			};
+
+			lcdif1: lcd-controller@32e80000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-lcdif1";
+				reg = <0x32e80000 0x10000>;
+				clocks = <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_PIXEL>,
+					 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_AXI>,
+					 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_APB>;
+				clock-names = "pix", "disp-axi", "disp-apb";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_DISP1_PIX>,
+						  <&clk IMX8MP_CLK_MEDIA_AXI>,
+						  <&clk IMX8MP_CLK_MEDIA_APB>;
+				assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>,
+							 <&clk IMX8MP_SYS_PLL2_1000M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <0>, <500000000>, <200000000>;
+				interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+				blk-ctl = <&media_blk_ctrl>;
+				resets = <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_APB>;
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				lcdif1_disp: port@0 {
+					reg = <0>;
+
+					lcdif_to_dsim: endpoint {
+						remote-endpoint = <&dsim_from_lcdif>;
+					};
+				};
+			};
+
+			lcdif2: lcd-controller@32e90000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-lcdif2";
+				reg = <0x32e90000 0x10000>;
+				clocks = <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_PIXEL>,
+					 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_AXI>,
+					 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_APB>;
+				clock-names = "pix", "disp-axi", "disp-apb";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_DISP2_PIX>,
+						  <&clk IMX8MP_CLK_MEDIA_AXI>,
+						  <&clk IMX8MP_CLK_MEDIA_APB>;
+				assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>,
+							 <&clk IMX8MP_SYS_PLL2_1000M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <0>, <500000000>, <200000000>;
+				interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				lcdif2_disp: port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					lcdif2_disp_ldb_ch0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&ldb_ch0>;
+					};
+
+					lcdif2_disp_ldb_ch1: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&ldb_ch1>;
+					};
+				};
+			};
+
+			media_blk_ctrl: media-blk-ctrl@32ec0000 {
+				compatible = "fsl,imx8mp-media-blk-ctrl", "syscon";
+				reg = <0x32ec0000 0x10000>;
+				power-domains = <&mediamix_pd>;
+
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+			};
+
+			ldb: ldb@32ec005c {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-ldb";
+				clocks = <&clk IMX8MP_CLK_MEDIA_LDB_ROOT>;
+				clock-names = "ldb";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_LDB>;
+				assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>;
+				gpr = <&media_blk_ctrl>;
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				lvds-channel@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+					phys = <&ldb_phy1>;
+					phy-names = "ldb_phy";
+					status = "disabled";
+
+					port@0 {
+						reg = <0>;
+
+						ldb_ch0: endpoint {
+							remote-endpoint = <&lcdif2_disp_ldb_ch0>;
+						};
+					};
+				};
+
+				lvds-channel@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+					phys = <&ldb_phy2>;
+					phy-names = "ldb_phy";
+					status = "disabled";
+
+					port@0 {
+						reg = <0>;
+
+						ldb_ch1: endpoint {
+							remote-endpoint = <&lcdif2_disp_ldb_ch1>;
+						};
+					};
+				};
+			};
+
+			ldb_phy: phy@32ec0128 {
+				compatible = "fsl,imx8mp-lvds-phy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				gpr = <&media_blk_ctrl>;
+				clocks = <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+				clock-names = "apb";
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				ldb_phy1: port@0 {
+					reg = <0>;
+					#phy-cells = <0>;
+				};
+
+				ldb_phy2: port@1 {
+					reg = <1>;
+					#phy-cells = <0>;
+				};
+			};
+
+			mediamix_gpr: media_gpr@32ec0008 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32ec0008 0x4>;
+			};
+
+			mediamix_gasket0: gasket@32ec0060 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32ec0060 0x28>;
+			};
+
+			mediamix_gasket1: gasket@32ec0090 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32ec0090 0x28>;
+			};
+
+			isi_chain_buf: isi_chain@32e02000{
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32e02000 0x4>;
+			};
+
+			cameradev: camera {
+				compatible = "fsl,mxc-md", "simple-bus";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges;
+				status = "disabled";
+
+				isi_0: isi@32e00000 {
+					compatible = "fsl,imx8mp-isi", "fsl,imx8mn-isi";
+					reg = <0x32e00000 0x2000>;
+					interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+					interface = <2 0 2>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+						 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_BUS_BLK>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB>;
+					clock-names = "disp_axi",
+						      "disp_apb",
+						      "disp_axi_root",
+						      "disp_apb_root",
+						      "media_blk_bus",
+						      "media_blk_isi_proc",
+						      "media_blk_isi_apb";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+							  <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+					assigned-clock-rates = <500000000>, <200000000>;
+					resets = <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_PROC>,
+						 <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_APB>,
+						 <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_BUS_BLK>;
+					reset-names = "isi_rst_proc", "isi_rst_apb", "isi_rst_bus";
+					power-domains = <&mediamix_pd>;
+					isi_chain = <&isi_chain_buf>;
+					status = "disabled";
+
+					cap_device {
+						compatible = "imx-isi-capture";
+						status = "disabled";
+					};
+
+					m2m_device{
+						compatible = "imx-isi-m2m";
+						status = "disabled";
+					};
+				};
+
+				isi_1: isi@32e02000 {
+					compatible = "fsl,imx8mp-isi", "fsl,imx8mn-isi";
+					reg = <0x32e02000 0x2000>;
+					interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+					interface = <3 0 2>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+						 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_BUS_BLK>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB>;
+					clock-names = "disp_axi",
+						      "disp_apb",
+						      "disp_axi_root",
+						      "disp_apb_root",
+						      "media_blk_bus",
+						      "media_blk_isi_proc",
+						      "media_blk_isi_apb";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+							  <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+					assigned-clock-rates = <500000000>, <200000000>;
+					resets = <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_PROC>,
+						 <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_APB>,
+						 <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_BUS_BLK>;
+					reset-names = "isi_rst_proc", "isi_rst_apb", "isi_rst_bus";
+					power-domains = <&mediamix_pd>;
+					status = "disabled";
+
+					cap_device {
+						compatible = "imx-isi-capture";
+						status = "disabled";
+					};
+				};
+
+				dewarp: dwe@32e30000 {
+					compatible = "fsl,imx8mp-dwe";
+					clocks = <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_COR>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AXI>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AHB>;
+					clock-names = "core", "axi", "ahb";
+					reg = <0x32e30000 0x10000>;
+					interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+					power-domains = <&ispdwp_pd>;
+					status = "disabled";
+				};
+
+				isp_0: isp@32e10000 {
+					compatible = "fsl,imx8mp-isp";
+					reg = <0x32e10000 0x10000>;
+					interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB>;
+					clock-names = "core", "axi", "ahb";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_ISP>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>;
+					assigned-clock-rates = <500000000>;
+					power-domains = <&ispdwp_pd>;
+					id = <0>;
+					gpr = <&media_blk_ctrl>;
+					memory-region = <&isp0_reserved>;
+					status = "disabled";
+				};
+
+				isp_1: isp@32e20000 {
+					compatible = "fsl,imx8mp-isp";
+					reg = <0x32e20000 0x10000>;
+					interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB>;
+					clock-names = "core", "axi", "ahb";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_ISP>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>;
+					assigned-clock-rates = <500000000>;
+					power-domains = <&ispdwp_pd>;
+					id = <1>;
+					gpr = <&media_blk_ctrl>;
+					status = "disabled";
+				};
+
+				mipi_csi_0: csi@32e40000 {
+					compatible = "fsl,imx8mp-mipi-csi", "fsl,imx8mn-mipi-csi";
+					reg = <0x32e40000 0x10000>;
+					interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+					clock-frequency = <500000000>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_CAM1_PIX>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_PCLK>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_ACLK>;
+					clock-names = "mipi_clk",
+						      "disp_axi",
+						      "disp_apb",
+						      "media_blk_csi_pclk",
+						      "media_blk_csi_aclk";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_CAM1_PIX>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>;
+					assigned-clock-rates = <500000000>;
+					bus-width = <4>;
+					csi-gpr = <&mediamix_gasket0>;
+					gpr = <&media_blk_ctrl>;
+					resets = <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_PCLK>,
+						 <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_ACLK>;
+					reset-names = "csi_rst_pclk", "csi_rst_aclk";
+					power-domains = <&mipi_phy1_pd>;
+					status = "disabled";
+				};
+
+				mipi_csi_1: csi@32e50000 {
+					compatible = "fsl,imx8mp-mipi-csi", "fsl,imx8mn-mipi-csi";
+					reg = <0x32e50000 0x10000>;
+					interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+					clock-frequency = <266000000>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_CAM2_PIX>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_PCLK>,
+						 <&media_blk_ctrl IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_ACLK>;
+					clock-names = "mipi_clk",
+						      "disp_axi",
+						      "disp_apb",
+						      "media_blk_csi_pclk",
+						      "media_blk_csi_aclk";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_CAM2_PIX>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_266M>;
+					assigned-clock-rates = <266000000>;
+					bus-width = <4>;
+					csi-gpr = <&mediamix_gasket1>;
+					gpr = <&media_blk_ctrl>;
+					resets = <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_PCLK>,
+						 <&media_blk_ctrl IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_ACLK>;
+					reset-names = "csi_rst_pclk", "csi_rst_aclk";
+					power-domains = <&mipi_phy2_pd>;
+					status = "disabled";
+				};
+			};
+
+			pcie_phy: pcie-phy@32f00000 {
+				compatible = "fsl,imx8mp-pcie-phy";
+				reg = <0x32f00000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_DUMMY>;
+				clock-names = "phy";
+				#phy-cells = <0>;
+				status = "disabled";
+			};
+
+			hsio_mix: hsio-mix@32f10000 {
+				  compatible = "fsl,imx8mp-hsio-mix";
+				  reg = <0x32f10000 0x8>;
+			};
+		};
+
+		aips5: bus@30c00000 {
+			compatible = "fsl,aips-bus", "simple-bus";
+			reg = <0x30c00000 0x10000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			spba-bus@30c00000 {
+				compatible = "fsl,spba-bus", "simple-bus";
+				reg = <0x30c00000 0x100000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges;
+
+				sai1: sai@30c10000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c10000 0x10000>;
+					interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 0 2 0>, <&sdma2 1 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0xff 0xff>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai2: sai@30c20000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c20000 0x10000>;
+					interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 2 2 0>, <&sdma2 3 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0xf 0xf>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai3: sai@30c30000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c30000 0x10000>;
+					interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 4 2 0>, <&sdma2 5 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0x3 0x3>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai5: sai@30c50000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c50000 0x10000>;
+					interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 8 2 0>, <&sdma2 9 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0xf 0xf>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai6: sai@30c60000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c60000 0x10000>;
+					interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_IPG>,
+						 <&clk IMX8MP_CLK_DUMMY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1>,
+						 <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 10 2 0>, <&sdma2 11 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai7: sai@30c80000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c80000 0x10000>;
+					interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 12 2 0>, <&sdma2 13 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				easrc: easrc@30c90000 {
+					compatible = "fsl,imx8mn-easrc";
+					reg = <0x30c90000 0x10000>;
+					interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_ASRC_IPG>;
+					clock-names = "mem";
+					dmas = <&sdma2 16 23 0> , <&sdma2 17 23 0>,
+					       <&sdma2 18 23 0> , <&sdma2 19 23 0>,
+					       <&sdma2 20 23 0> , <&sdma2 21 23 0>,
+					       <&sdma2 22 23 0> , <&sdma2 23 23 0>;
+					dma-names = "ctx0_rx", "ctx0_tx",
+						    "ctx1_rx", "ctx1_tx",
+						    "ctx2_rx", "ctx2_tx",
+						    "ctx3_rx", "ctx3_tx";
+					fsl,easrc-ram-script-name = "imx/easrc/easrc-imx8mn.bin";
+					fsl,asrc-rate  = <8000>;
+					fsl,asrc-width = <16>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				micfil: micfil@30ca0000 {
+					compatible = "fsl,imx8mp-micfil";
+					reg = <0x30ca0000 0x10000>;
+					interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_IPG>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_ROOT>,
+						 <&clk IMX8MP_AUDIO_PLL1_OUT>,
+						 <&clk IMX8MP_AUDIO_PLL2_OUT>,
+						 <&clk IMX8MP_CLK_EXT3>;
+					clock-names = "ipg_clk", "ipg_clk_app",
+						      "pll8k", "pll11k", "clkext3";
+					dmas = <&sdma2 24 25 0x80000000>;
+					dma-names = "rx";
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				aud2htx: aud2htx@30cb0000 {
+					compatible = "fsl,imx8mp-aud2htx";
+					reg = <0x30cb0000 0x10000>;
+					interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_AUD2HTX_IPG>;
+					clock-names = "bus";
+					dmas = <&sdma2 26 2 0>;
+					dma-names = "tx";
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				xcvr: xcvr@30cc0000 {
+					compatible = "fsl,imx8mp-xcvr";
+					reg = <0x30cc0000 0x800>,
+					      <0x30cc0800 0x400>,
+					      <0x30cc0c00 0x080>,
+					      <0x30cc0e00 0x080>;
+					reg-names = "ram", "regs", "rxfifo",
+					            "txfifo";
+					interrupts = /* XCVR IRQ 0 */
+						     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
+						     /* XCVR IRQ 1 */
+						     <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
+						     /* XCVR PHY - SPDIF wakeup IRQ */
+						     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_IPG>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_PHY>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SPBA2_ROOT>,
+						 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_AUDPLL_ROOT>;
+					clock-names = "ipg", "phy", "spba", "pll_ipg";
+					dmas = <&sdma2 30 2 0>, <&sdma2 31 2 0>;
+					dma-names = "rx", "tx";
+					resets = <&audio_blk_ctrl 0>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+			};
+
+			sdma3: dma-controller@30e00000 {
+				compatible = "fsl,imx8mp-sdma", "fsl,imx7d-sdma";
+				reg = <0x30e00000 0x10000>;
+				interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT>,
+					 <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT>;
+				clock-names = "ipg", "ahb";
+				#dma-cells = <3>;
+				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
+				fsl,ratio-1-1;
+				power-domains = <&audiomix_pd>;
+				status = "disabled";
+			};
+
+			sdma2: dma-controller@30e10000 {
+				compatible = "fsl,imx8mp-sdma", "fsl,imx7d-sdma";
+				reg = <0x30e10000 0x10000>;
+				interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_AUDIO_AHB_ROOT>,
+					 <&clk IMX8MP_CLK_AUDIO_AHB_ROOT>;
+				clock-names = "ipg", "ahb";
+				#dma-cells = <3>;
+				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
+				fsl,ratio-1-1;
+				power-domains = <&audiomix_pd>;
+				status = "disabled";
+			};
+
+			audio_blk_ctrl: audio-blk-ctrl@30e20000 {
+				compatible = "fsl,imx8mp-audio-blk-ctrl", "syscon";
+				reg = <0x30e20000 0x50C>;
+				power-domains = <&audiomix_pd>;
+
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+
+				assigned-clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_BYPASS>;
+				assigned-clock-parents = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL>;
+			};
+
+			audiomix_dsp: audiomix_dsp {
+				compatible = "fsl,audiomix-dsp";
+				power-domains = <&audiomix_pd>;
+			};
+
+			mu2: mu2@30e60000 {
+				compatible = "fsl,imx8-mu-dsp", "fsl,imx6sx-mu";
+				reg = <0x30E60000 0x10000>;
+				interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+				fsl,dsp_ap_mu_id = <2>;
+				 #mbox-cells = <2>;
+				clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIO_BLK_CTRL_MU2_ROOT>;
+				status = "okay";
+			};
+
+			hdmi_blk_ctrl: hdmi-blk-ctrl@32fc0000 {
+				compatible = "fsl,imx8mp-hdmi-blk-ctrl", "syscon";
+				reg = <0x32fc0000 0x1000>;
+				power-domains = <&hdmimix_pd>;
+
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+			};
+
+			irqsteer_hdmi: irqsteer@32fc2000 {
+				compatible = "fsl,imx-irqsteer";
+				reg = <0x32fc2000 0x1000>;
+				interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				fsl,channel = <1>;
+				fsl,num-irqs = <64>;
+				clocks = <&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_IRQS_STEER_CLK>;
+				clock-names = "ipg";
+				assigned-clocks = <&clk IMX8MP_CLK_HDMI_APB>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <200000000>;
+				resets = <&hdmi_blk_ctrl IMX8MP_HDMI_BLK_CTRL_IRQ_STEER_RESET>;
+				status = "disabled";
+			};
+
+			hdmi_pavi: hdmi-pai-pvi@32fc4000 {
+				compatible = "fsl,imx8mp-hdmi-pavi";
+				reg = <0x32fc4000 0x1000>;
+				clocks = <&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_VID_LINK_PIX_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_GPA_CLK>;
+				clock-names = "pvi_clk", "pai_clk";
+				resets = <&hdmi_blk_ctrl IMX8MP_HDMI_BLK_CTRL_HDMI_PAI_RESET>,
+						<&hdmi_blk_ctrl IMX8MP_HDMI_BLK_CTRL_HDMI_PVI_RESET>;
+				reset-names = "pai_rst", "pvi_rst";
+				status = "disabled";
+			};
+
+			lcdif3: lcd-controller@32fc6000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-lcdif3";
+				reg = <0x32fc6000 0x10000>;
+				clocks = <&hdmiphy 0>,
+						<&clk IMX8MP_CLK_HDMI_AXI>,
+						<&clk IMX8MP_CLK_HDMI_APB>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_APB_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_B_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_TX_PIX_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_APB_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_B_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PDI_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PIX_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_SPU_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDMI_CLK>;
+				clock-names = "pix", "disp-axi", "disp-apb",
+							"mix_apb","mix_axi", "xtl_24m", "mix_pix", "lcdif_apb",
+							"lcdif_axi", "lcdif_pdi", "lcdif_pix", "lcdif_spu",
+							"noc_hdmi";
+				assigned-clocks =  <&clk IMX8MP_CLK_HDMI_AXI>,
+								<&clk IMX8MP_CLK_HDMI_APB>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <500000000>, <200000000>;
+				interrupts = <8 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-parent = <&irqsteer_hdmi>;
+				resets = <&hdmi_blk_ctrl IMX8MP_HDMI_BLK_CTRL_LCDIF_RESET>;
+				power-domains = <&hdmimix_pd>;
+				status = "disabled";
+
+				lcdif3_disp: port@0 {
+					reg = <0>;
+
+					lcdif3_to_hdmi: endpoint {
+						remote-endpoint = <&hdmi_from_lcdif3>;
+					};
+				};
+			};
+
+			hdmi: hdmi@32fd8000 {
+				compatible = "fsl,imx8mp-hdmi";
+				reg = <0x32fd8000 0x7eff>;
+				interrupts = <0 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-parent = <&irqsteer_hdmi>;
+				clocks = <&clk IMX8MP_CLK_HDMI_APB>,
+						<&clk IMX8MP_CLK_HDMI_24M>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_INT_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_PREP_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_SKP_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_SFR_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIXEL_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_CEC_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_APB_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_HPI_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_FDCC_REF_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIPE_CLK_SEL>;
+				clock-names = "iahb", "isfr",
+								"phy_int", "prep_clk", "skp_clk", "sfr_clk", "pix_clk",
+								"cec_clk", "apb_clk", "hpi_clk", "fdcc_ref", "pipe_clk";
+				assigned-clocks = <&clk IMX8MP_CLK_HDMI_APB>,
+							<&clk IMX8MP_CLK_HDMI_AXI>,
+							<&clk IMX8MP_CLK_HDMI_24M>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>,
+							<&clk IMX8MP_SYS_PLL2_500M>,
+							<&clk IMX8MP_CLK_24M>;
+				assigned-clock-rates = <200000000>, <500000000>, <24000000>;
+				phys = <&hdmiphy>;
+				phy-names = "hdmi";
+				resets = <&hdmi_blk_ctrl IMX8MP_HDMI_BLK_CTRL_HDMI_TX_RESET>;
+				gpr = <&hdmi_blk_ctrl>;
+				power-domains = <&hdmi_phy_pd>;
+				status = "disabled";
+
+				port@0 {
+					hdmi_from_lcdif3: endpoint {
+						remote-endpoint = <&lcdif3_to_hdmi>;
+					};
+				};
+			};
+
+			hdmiphy: hdmiphy@32fdff00 {
+				compatible = "fsl,samsung-hdmi-phy";
+				reg = <0x32fdff00 0x100>;
+				#clock-cells = <1>;
+				clocks = <&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_APB_CLK>,
+						<&hdmi_blk_ctrl IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK>;
+				clock-names = "apb", "ref";
+				clock-output-names = "hdmi_phy";
+				#phy-cells = <0>;
+				resets = <&hdmi_blk_ctrl IMX8MP_HDMI_BLK_CTRL_HDMI_PHY_RESET>;
 				status = "disabled";
 			};
 		};
diff --git a/drivers/clk/imx/Makefile b/drivers/clk/imx/Makefile
index dd6a737d060b..6bb11273acbf 100644
--- a/drivers/clk/imx/Makefile
+++ b/drivers/clk/imx/Makefile
@@ -23,7 +23,7 @@ obj-$(CONFIG_MXC_CLK) += mxc-clk.o
 
 obj-$(CONFIG_CLK_IMX8MM) += clk-imx8mm.o
 obj-$(CONFIG_CLK_IMX8MN) += clk-imx8mn.o
-obj-$(CONFIG_CLK_IMX8MP) += clk-imx8mp.o
+obj-$(CONFIG_CLK_IMX8MP) += clk-imx8mp.o clk-blk-ctrl.o
 obj-$(CONFIG_CLK_IMX8MQ) += clk-imx8mq.o
 
 obj-$(CONFIG_MXC_CLK_SCU) += clk-imx-scu.o clk-imx-lpcg-scu.o
diff --git a/drivers/clk/imx/clk-blk-ctrl.c b/drivers/clk/imx/clk-blk-ctrl.c
new file mode 100644
index 000000000000..8ed98e7bddd7
--- /dev/null
+++ b/drivers/clk/imx/clk-blk-ctrl.c
@@ -0,0 +1,341 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright 2020 NXP.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset-controller.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include "clk.h"
+#include "clk-blk-ctrl.h"
+
+struct reset_hw {
+	u32 offset;
+	u32 shift;
+	u32 mask;
+	unsigned long asserted;
+};
+
+struct pm_safekeep_info {
+	uint32_t *regs_values;
+	uint32_t *regs_offsets;
+	uint32_t regs_num;
+};
+
+struct imx_blk_ctrl_drvdata {
+	void __iomem *base;
+	struct reset_controller_dev rcdev;
+	struct reset_hw *rst_hws;
+	struct pm_safekeep_info pm_info;
+
+	spinlock_t *lock;
+};
+
+static int imx_blk_ctrl_reset_set(struct reset_controller_dev *rcdev,
+				  unsigned long id, bool assert)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = container_of(rcdev,
+			struct imx_blk_ctrl_drvdata, rcdev);
+	unsigned int offset = drvdata->rst_hws[id].offset;
+	unsigned int shift = drvdata->rst_hws[id].shift;
+	unsigned int mask = drvdata->rst_hws[id].mask;
+	void __iomem *reg_addr = drvdata->base + offset;
+	unsigned long flags;
+	u32 reg;
+
+	if (!assert && !test_bit(1, &drvdata->rst_hws[id].asserted))
+		return -ENODEV;
+
+	if (assert && !test_and_set_bit(1, &drvdata->rst_hws[id].asserted))
+		pm_runtime_get_sync(rcdev->dev);
+
+	spin_lock_irqsave(drvdata->lock, flags);
+
+	reg = readl(reg_addr);
+	if (assert)
+		writel(reg & ~(mask << shift), reg_addr);
+	else
+		writel(reg | (mask << shift), reg_addr);
+
+	spin_unlock_irqrestore(drvdata->lock, flags);
+
+	if (!assert && test_and_clear_bit(1, &drvdata->rst_hws[id].asserted))
+		pm_runtime_put(rcdev->dev);
+
+	return 0;
+}
+
+static int imx_blk_ctrl_reset_reset(struct reset_controller_dev *rcdev,
+					   unsigned long id)
+{
+	imx_blk_ctrl_reset_set(rcdev, id, true);
+	return imx_blk_ctrl_reset_set(rcdev, id, false);
+}
+
+static int imx_blk_ctrl_reset_assert(struct reset_controller_dev *rcdev,
+					   unsigned long id)
+{
+	return imx_blk_ctrl_reset_set(rcdev, id, true);
+}
+
+static int imx_blk_ctrl_reset_deassert(struct reset_controller_dev *rcdev,
+					     unsigned long id)
+{
+	return imx_blk_ctrl_reset_set(rcdev, id, false);
+}
+
+static const struct reset_control_ops imx_blk_ctrl_reset_ops = {
+	.reset		= imx_blk_ctrl_reset_reset,
+	.assert		= imx_blk_ctrl_reset_assert,
+	.deassert	= imx_blk_ctrl_reset_deassert,
+};
+
+static int imx_blk_ctrl_register_reset_controller(struct device *dev)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	const struct imx_blk_ctrl_dev_data *dev_data = of_device_get_match_data(dev);
+	struct reset_hw *hws;
+	int max = dev_data->resets_max;
+	int i;
+
+	drvdata->lock = &imx_ccm_lock;
+
+	drvdata->rcdev.owner     = THIS_MODULE;
+	drvdata->rcdev.nr_resets = max;
+	drvdata->rcdev.ops       = &imx_blk_ctrl_reset_ops;
+	drvdata->rcdev.of_node   = dev->of_node;
+	drvdata->rcdev.dev	 = dev;
+
+	drvdata->rst_hws = devm_kzalloc(dev, sizeof(struct reset_hw) * max,
+					GFP_KERNEL);
+	hws = drvdata->rst_hws;
+
+	for (i = 0; i < dev_data->hws_num; i++) {
+		struct imx_blk_ctrl_hw *hw = &dev_data->hws[i];
+
+		if (hw->type != BLK_CTRL_RESET)
+			continue;
+
+		hws[hw->id].offset = hw->offset;
+		hws[hw->id].shift = hw->shift;
+		hws[hw->id].mask = hw->mask;
+	}
+
+	return devm_reset_controller_register(dev, &drvdata->rcdev);
+}
+static struct clk_hw *imx_blk_ctrl_register_one_clock(struct device *dev,
+						struct imx_blk_ctrl_hw *hw)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	void __iomem *base = drvdata->base;
+	struct clk_hw *clk_hw;
+
+	switch (hw->type) {
+	case BLK_CTRL_CLK_MUX:
+		clk_hw = imx_dev_clk_hw_mux_flags(dev, hw->name,
+						  base + hw->offset,
+						  hw->shift, hw->width,
+						  hw->parents,
+						  hw->parents_count,
+						  hw->flags);
+		break;
+	case BLK_CTRL_CLK_GATE:
+		clk_hw = imx_dev_clk_hw_gate(dev, hw->name, hw->parents,
+					     base + hw->offset, hw->shift);
+		break;
+	case BLK_CTRL_CLK_SHARED_GATE:
+		clk_hw = imx_dev_clk_hw_gate_shared(dev, hw->name,
+						    hw->parents,
+						    base + hw->offset,
+						    hw->shift,
+						    hw->shared_count);
+		break;
+	case BLK_CTRL_CLK_PLL14XX:
+		clk_hw = imx_dev_clk_hw_pll14xx(dev, hw->name, hw->parents,
+						base + hw->offset, hw->pll_tbl);
+		break;
+	default:
+		clk_hw = NULL;
+	};
+
+	return clk_hw;
+}
+
+static int imx_blk_ctrl_register_clock_controller(struct device *dev)
+{
+	const struct imx_blk_ctrl_dev_data *dev_data = of_device_get_match_data(dev);
+	struct clk_hw_onecell_data *clk_hw_data;
+	struct clk_hw **hws;
+	int i;
+
+	clk_hw_data = devm_kzalloc(dev, struct_size(clk_hw_data, hws,
+				dev_data->hws_num), GFP_KERNEL);
+	if (WARN_ON(!clk_hw_data))
+		return -ENOMEM;
+
+	clk_hw_data->num = dev_data->clocks_max;
+	hws = clk_hw_data->hws;
+
+	for (i = 0; i < dev_data->hws_num; i++) {
+		struct imx_blk_ctrl_hw *hw = &dev_data->hws[i];
+		struct clk_hw *tmp = imx_blk_ctrl_register_one_clock(dev, hw);
+
+		if (!tmp)
+			continue;
+		hws[hw->id] = tmp;
+	}
+
+	imx_check_clk_hws(hws, dev_data->clocks_max);
+
+	return of_clk_add_hw_provider(dev->of_node, of_clk_hw_onecell_get,
+					clk_hw_data);
+}
+
+static int imx_blk_ctrl_init_runtime_pm_safekeeping(struct device *dev)
+{
+	const struct imx_blk_ctrl_dev_data *dev_data = of_device_get_match_data(dev);
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	struct pm_safekeep_info *pm_info = &drvdata->pm_info;
+	u32 regs_num = dev_data->pm_runtime_saved_regs_num;
+	const u32 *regs_offsets = dev_data->pm_runtime_saved_regs;
+
+	if (!dev_data->pm_runtime_saved_regs_num)
+		return 0;
+
+	pm_info->regs_values = devm_kzalloc(dev,
+					    sizeof(u32) * regs_num,
+					    GFP_KERNEL);
+	if (WARN_ON(IS_ERR(pm_info->regs_values)))
+		return PTR_ERR(pm_info->regs_values);
+
+	pm_info->regs_offsets = kmemdup(regs_offsets,
+					regs_num * sizeof(u32), GFP_KERNEL);
+	if (WARN_ON(IS_ERR(pm_info->regs_offsets)))
+		return PTR_ERR(pm_info->regs_offsets);
+
+	pm_info->regs_num = regs_num;
+
+	return 0;
+}
+
+static int imx_blk_ctrl_probe(struct platform_device *pdev)
+{
+	struct imx_blk_ctrl_drvdata *drvdata;
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);
+	if (WARN_ON(!drvdata))
+		return -ENOMEM;
+
+	drvdata->base = devm_platform_ioremap_resource(pdev, 0);
+	if (WARN_ON(IS_ERR(drvdata->base)))
+		return PTR_ERR(drvdata->base);
+
+	dev_set_drvdata(dev, drvdata);
+
+	ret = imx_blk_ctrl_init_runtime_pm_safekeeping(dev);
+	if (ret)
+		return ret;
+
+	pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	ret = imx_blk_ctrl_register_clock_controller(dev);
+	if (ret) {
+		pm_runtime_put(dev);
+		return ret;
+	}
+
+	ret = imx_blk_ctrl_register_reset_controller(dev);
+
+	pm_runtime_put(dev);
+
+	return ret;
+}
+
+static void imx_blk_ctrl_read_write(struct device *dev, bool write)
+{
+	struct imx_blk_ctrl_drvdata *drvdata = dev_get_drvdata(dev);
+	struct pm_safekeep_info *pm_info = &drvdata->pm_info;
+	void __iomem *base = drvdata->base;
+	unsigned long flags;
+	int i;
+
+	if (!pm_info->regs_num)
+		return;
+
+	spin_lock_irqsave(drvdata->lock, flags);
+
+	for (i = 0; i < pm_info->regs_num; i++) {
+		u32 offset = pm_info->regs_offsets[i];
+
+		if (write)
+			writel(pm_info->regs_values[i], base + offset);
+		else
+			pm_info->regs_values[i] = readl(base + offset);
+	}
+
+	spin_unlock_irqrestore(drvdata->lock, flags);
+
+}
+
+static int imx_blk_ctrl_runtime_suspend(struct device *dev)
+{
+	imx_blk_ctrl_read_write(dev, false);
+
+	return 0;
+}
+
+static int imx_blk_ctrl_runtime_resume(struct device *dev)
+{
+	imx_blk_ctrl_read_write(dev, true);
+
+	return 0;
+}
+
+static const struct dev_pm_ops imx_blk_ctrl_pm_ops = {
+	SET_RUNTIME_PM_OPS(imx_blk_ctrl_runtime_suspend,
+			   imx_blk_ctrl_runtime_resume, NULL)
+	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
+			   pm_runtime_force_resume)
+};
+
+static const struct of_device_id imx_blk_ctrl_of_match[] = {
+	{
+		.compatible = "fsl,imx8mp-audio-blk-ctrl",
+		.data = &imx8mp_audio_blk_ctrl_dev_data
+	},
+	{
+		.compatible = "fsl,imx8mp-media-blk-ctrl",
+		.data = &imx8mp_media_blk_ctrl_dev_data
+	},
+	{
+		.compatible = "fsl,imx8mp-hdmi-blk-ctrl",
+		.data = &imx8mp_hdmi_blk_ctrl_dev_data
+	},
+	{ /* Sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, imx_blk_ctrl_of_match);
+
+static struct platform_driver imx_blk_ctrl_driver = {
+	.probe = imx_blk_ctrl_probe,
+	.driver = {
+		.name = "imx-blk-ctrl",
+		.of_match_table = of_match_ptr(imx_blk_ctrl_of_match),
+		.pm = &imx_blk_ctrl_pm_ops,
+	},
+};
+module_platform_driver(imx_blk_ctrl_driver);
diff --git a/drivers/clk/imx/clk-blk-ctrl.h b/drivers/clk/imx/clk-blk-ctrl.h
new file mode 100644
index 000000000000..b3b7fc37f6a7
--- /dev/null
+++ b/drivers/clk/imx/clk-blk-ctrl.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __MACH_IMX_CLK_BLK_CTRL_H
+#define __MACH_IMX_CLK_BLK_CTRL_H
+
+enum imx_blk_ctrl_hw_type {
+	BLK_CTRL_CLK_MUX,
+	BLK_CTRL_CLK_GATE,
+	BLK_CTRL_CLK_SHARED_GATE,
+	BLK_CTRL_CLK_PLL14XX,
+	BLK_CTRL_RESET,
+};
+
+struct imx_blk_ctrl_hw {
+	int type;
+	char *name;
+	u32 offset;
+	u32 shift;
+	u32 mask;
+	u32 width;
+	u32 flags;
+	u32 id;
+	void *parents;
+	u32 parents_count;
+	int *shared_count;
+	struct imx_pll14xx_clk *pll_tbl;
+};
+
+struct imx_blk_ctrl_dev_data {
+	struct imx_blk_ctrl_hw *hws;
+	u32 hws_num;
+
+	u32 clocks_max;
+	u32 resets_max;
+
+	u32 pm_runtime_saved_regs_num;
+	u32 pm_runtime_saved_regs[];
+};
+
+#define IMX_BLK_CTRL(_type, _name, _id, _offset, _shift, _width, _mask, _parents, _parents_count, _flags, sh_count, _pll_tbl) \
+	{						\
+		.type = _type,				\
+		.name = _name,				\
+		.id = _id,				\
+		.offset = _offset,			\
+		.shift = _shift,			\
+		.width = _width,			\
+		.mask = _mask,				\
+		.parents = _parents,			\
+		.parents_count = _parents_count,	\
+		.flags = _flags,			\
+		.shared_count = sh_count,		\
+		.pll_tbl = _pll_tbl,			\
+	}
+
+#define IMX_BLK_CTRL_CLK_MUX(_name, _id, _offset, _shift, _width, _parents) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_MUX, _name, _id, _offset, _shift, _width, 0, _parents, ARRAY_SIZE(_parents), 0, NULL, NULL)
+
+#define IMX_BLK_CTRL_CLK_MUX_FLAGS(_name, _id, _offset, _shift, _width, _parents, _flags) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_MUX, _name, _id, _offset, _shift, _width, 0, _parents, ARRAY_SIZE(_parents), _flags, NULL, NULL)
+
+#define IMX_BLK_CTRL_CLK_GATE(_name, _id, _offset, _shift, _parents) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_GATE, _name, _id, _offset, _shift, 1, 0, _parents, 1, 0, NULL, NULL)
+
+#define IMX_BLK_CTRL_CLK_SHARED_GATE(_name, _id, _offset, _shift, _parents, sh_count) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_SHARED_GATE, _name, _id, _offset, _shift, 1, 0, _parents, 1, 0, sh_count, NULL)
+
+#define IMX_BLK_CTRL_CLK_PLL14XX(_name, _id, _offset, _parents, _pll_tbl) \
+	IMX_BLK_CTRL(BLK_CTRL_CLK_PLL14XX, _name, _id, _offset, 0, 0, 0, _parents, 1, 0, NULL, _pll_tbl)
+
+#define IMX_BLK_CTRL_RESET(_id, _offset, _shift) \
+	IMX_BLK_CTRL(BLK_CTRL_RESET, NULL, _id, _offset, _shift, 0, 1, NULL, 0, 0, NULL, NULL)
+
+#define IMX_BLK_CTRL_RESET_MASK(_id, _offset, _shift, mask) \
+	IMX_BLK_CTRL(BLK_CTRL_RESET, NULL, _id, _offset, _shift, 0, mask, NULL, 0, 0, NULL, NULL)
+
+extern const struct imx_blk_ctrl_dev_data imx8mp_audio_blk_ctrl_dev_data __initconst;
+extern const struct imx_blk_ctrl_dev_data imx8mp_media_blk_ctrl_dev_data __initconst;
+extern const struct imx_blk_ctrl_dev_data imx8mp_hdmi_blk_ctrl_dev_data __initconst;
+
+#endif
+
diff --git a/drivers/clk/imx/clk-imx7d.c b/drivers/clk/imx/clk-imx7d.c
index 3f6fd7ef2a68..2da151d7e594 100644
--- a/drivers/clk/imx/clk-imx7d.c
+++ b/drivers/clk/imx/clk-imx7d.c
@@ -782,7 +782,7 @@ static void __init imx7d_clocks_init(struct device_node *ccm_node)
 	hws[IMX7D_DRAM_PHYM_ALT_ROOT_CLK] = imx_clk_hw_gate2_flags("dram_phym_alt_root_clk", "dram_phym_alt_post_div", base + 0x4130, 0, CLK_IS_CRITICAL | CLK_OPS_PARENT_ENABLE);
 	hws[IMX7D_DRAM_ALT_ROOT_CLK] = imx_clk_hw_gate2_flags("dram_alt_root_clk", "dram_alt_post_div", base + 0x4130, 0, CLK_IS_CRITICAL | CLK_OPS_PARENT_ENABLE);
 	hws[IMX7D_OCOTP_CLK] = imx_clk_hw_gate4("ocotp_clk", "ipg_root_clk", base + 0x4230, 0);
-	hws[IMX7D_SNVS_CLK] = imx_clk_hw_gate4("snvs_clk", "ipg_root_clk", base + 0x4250, 0);
+	hws[IMX7D_SNVS_CLK] = imx_clk_hw_gate2_flags("snvs_clk", "ipg_root_clk", base + 0x4250, 0, CLK_IS_CRITICAL);
 	hws[IMX7D_MU_ROOT_CLK] = imx_clk_hw_gate4("mu_root_clk", "ipg_root_clk", base + 0x4270, 0);
 	hws[IMX7D_CAAM_CLK] = imx_clk_hw_gate4("caam_clk", "ipg_root_clk", base + 0x4240, 0);
 	hws[IMX7D_USB_HSIC_ROOT_CLK] = imx_clk_hw_gate4("usb_hsic_root_clk", "usb_hsic_post_div", base + 0x4690, 0);
diff --git a/drivers/clk/imx/clk-imx8mm.c b/drivers/clk/imx/clk-imx8mm.c
index 711bd2294c70..9f003f5845f9 100644
--- a/drivers/clk/imx/clk-imx8mm.c
+++ b/drivers/clk/imx/clk-imx8mm.c
@@ -5,6 +5,7 @@
 
 #include <dt-bindings/clock/imx8mm-clock.h>
 #include <linux/clk-provider.h>
+#include <linux/debugfs.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -565,7 +566,7 @@ static int imx8mm_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MM_CLK_SAI5_IPG] = imx_clk_hw_gate2_shared2("sai5_ipg_clk", "ipg_audio_root", base + 0x4370, 0, &share_count_sai5);
 	hws[IMX8MM_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root_clk", "sai6", base + 0x4380, 0, &share_count_sai6);
 	hws[IMX8MM_CLK_SAI6_IPG] = imx_clk_hw_gate2_shared2("sai6_ipg_clk", "ipg_audio_root", base + 0x4380, 0, &share_count_sai6);
-	hws[IMX8MM_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", base + 0x4470, 0);
+	hws[IMX8MM_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MM_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", base + 0x4490, 0);
 	hws[IMX8MM_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", base + 0x44a0, 0);
 	hws[IMX8MM_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", base + 0x44b0, 0);
@@ -645,6 +646,81 @@ static struct platform_driver imx8mm_clk_driver = {
 };
 module_platform_driver(imx8mm_clk_driver);
 
+/*
+ * Debugfs interface for audio PLL K divider change dynamically.
+ * Monitor control for the Audio PLL K-Divider
+ */
+#ifdef CONFIG_DEBUG_FS
+
+#define KDIV_MASK	GENMASK(15, 0)
+#define MDIV_SHIFT	12
+#define MDIV_MASK	GENMASK(21, 12)
+#define PDIV_SHIFT	4
+#define PDIV_MASK	GENMASK(9, 4)
+#define SDIV_SHIFT	0
+#define SDIV_MASK	GENMASK(2, 0)
+
+static int pll_delta_k_set(void *data, u64 val)
+{
+	struct clk_hw *hw;
+	short int delta_k;
+
+	hw = data;
+	delta_k = (short int) (val & KDIV_MASK);
+
+	clk_set_delta_k(hw, val);
+
+	pr_debug("the delta k is %d\n", delta_k);
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(delta_k_fops, NULL, pll_delta_k_set, "%lld\n");
+
+static int pll_setting_show(struct seq_file *s, void *data)
+{
+	struct clk_hw *hw;
+	u32 pll_div_ctrl0, pll_div_ctrl1;
+	u32 mdiv, pdiv, sdiv, kdiv;
+
+	hw = s->private;;
+
+	clk_get_pll_setting(hw, &pll_div_ctrl0, &pll_div_ctrl1);
+	mdiv = (pll_div_ctrl0 & MDIV_MASK) >> MDIV_SHIFT;
+	pdiv = (pll_div_ctrl0 & PDIV_MASK) >> PDIV_SHIFT;
+	sdiv = (pll_div_ctrl0 & SDIV_MASK) >> SDIV_SHIFT;
+	kdiv = (pll_div_ctrl1 & KDIV_MASK);
+
+	seq_printf(s, "Mdiv: 0x%x; Pdiv: 0x%x; Sdiv: 0x%x; Kdiv: 0x%x\n",
+		mdiv, pdiv, sdiv, kdiv);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(pll_setting);
+
+static int __init pll_debug_init(void)
+{
+	struct dentry *root, *audio_pll1, *audio_pll2;
+
+	if (of_machine_is_compatible("fsl,imx8mm")) {
+		/* create a root dir for audio pll monitor */
+		root = debugfs_create_dir("audio_pll_monitor", NULL);
+		audio_pll1 = debugfs_create_dir("audio_pll1", root);
+		audio_pll2 = debugfs_create_dir("audio_pll2", root);
+
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll1,
+			hws[IMX8MM_AUDIO_PLL1], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll1,
+			hws[IMX8MM_AUDIO_PLL1], &pll_setting_fops);
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll2,
+			hws[IMX8MM_AUDIO_PLL2], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll2,
+			hws[IMX8MM_AUDIO_PLL2], &pll_setting_fops);
+	}
+
+	return 0;
+}
+late_initcall(pll_debug_init);
+#endif /* CONFIG_DEBUG_FS */
+
 MODULE_AUTHOR("Bai Ping <ping.bai@nxp.com>");
 MODULE_DESCRIPTION("NXP i.MX8MM clock driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/clk/imx/clk-imx8mn.c b/drivers/clk/imx/clk-imx8mn.c
index db122d94db58..1a63f682c2d2 100644
--- a/drivers/clk/imx/clk-imx8mn.c
+++ b/drivers/clk/imx/clk-imx8mn.c
@@ -523,7 +523,7 @@ static int imx8mn_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MN_CLK_SAI5_IPG] = imx_clk_hw_gate2_shared2("sai5_ipg_clk", "ipg_audio_root", base + 0x4370, 0, &share_count_sai5);
 	hws[IMX8MN_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root_clk", "sai6", base + 0x4380, 0, &share_count_sai6);
 	hws[IMX8MN_CLK_SAI6_IPG] = imx_clk_hw_gate2_shared2("sai6_ipg_clk", "ipg_audio_root", base + 0x4380, 0, &share_count_sai6);
-	hws[IMX8MN_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", base + 0x4470, 0);
+	hws[IMX8MN_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MN_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", base + 0x4490, 0);
 	hws[IMX8MN_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", base + 0x44a0, 0);
 	hws[IMX8MN_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", base + 0x44b0, 0);
diff --git a/drivers/clk/imx/clk-imx8mp.c b/drivers/clk/imx/clk-imx8mp.c
index 0391f5bda5e4..d54d1ce407d9 100644
--- a/drivers/clk/imx/clk-imx8mp.c
+++ b/drivers/clk/imx/clk-imx8mp.c
@@ -4,7 +4,10 @@
  */
 
 #include <dt-bindings/clock/imx8mp-clock.h>
+#include <dt-bindings/reset/imx8mp-reset.h>
+#include <linux/clk.h>
 #include <linux/clk-provider.h>
+#include <linux/debugfs.h>
 #include <linux/err.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -12,11 +15,286 @@
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/types.h>
+#include <soc/imx/soc.h>
 
 #include "clk.h"
+#include "clk-blk-ctrl.h"
+
+#define	IMX_AUDIO_BLK_CTRL_CLKEN0		0x0
+#define	IMX_AUDIO_BLK_CTRL_CLKEN1		0x4
+#define	IMX_AUDIO_BLK_CTRL_EARC			0x200
+#define	IMX_AUDIO_BLK_CTRL_SAI1_MCLK_SEL	0x300
+#define	IMX_AUDIO_BLK_CTRL_SAI2_MCLK_SEL	0x304
+#define	IMX_AUDIO_BLK_CTRL_SAI3_MCLK_SEL	0x308
+#define	IMX_AUDIO_BLK_CTRL_SAI5_MCLK_SEL	0x30C
+#define	IMX_AUDIO_BLK_CTRL_SAI6_MCLK_SEL	0x310
+#define	IMX_AUDIO_BLK_CTRL_SAI7_MCLK_SEL	0x314
+#define	IMX_AUDIO_BLK_CTRL_PDM_CLK		0x318
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_GNRL_CTL	0x400
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL0	0x404
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL1	0x408
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_SSCG_CTL	0x40C
+#define	IMX_AUDIO_BLK_CTRL_SAI_PLL_MNIT_CTL	0x410
+#define	IMX_AUDIO_BLK_CTRL_IPG_LP_CTRL		0x504
+
+#define IMX_MEDIA_BLK_CTRL_SFT_RSTN		0x0
+#define IMX_MEDIA_BLK_CTRL_CLK_EN		0x4
 
 static u32 share_count_nand;
 static u32 share_count_media;
+static u32 share_count_audio;
+
+static int shared_count_pdm;
+
+/* descending order */
+static const struct imx_pll14xx_rate_table imx_blk_ctrl_sai_pll_tbl[] = {
+	PLL_1443X_RATE(245760000U, 328, 4, 3, 0xae15),
+	PLL_1443X_RATE(225792000U, 226, 3, 3, 0xcac1),
+	PLL_1443X_RATE(122880000U, 328, 4, 4, 0xae15),
+	PLL_1443X_RATE(112896000U, 226,	3, 4, 0xcac1),
+	PLL_1443X_RATE(61440000U, 328, 4, 5, 0xae15),
+	PLL_1443X_RATE(56448000U, 226, 3, 5, 0xcac1),
+	PLL_1443X_RATE(49152000U, 393, 3, 6, 0x374c),
+	PLL_1443X_RATE(45158400U, 241, 2, 6, 0xd845),
+	PLL_1443X_RATE(40960000U, 109, 1, 6, 0x3a07),
+};
+
+static const struct imx_pll14xx_clk imx_blk_ctrl_sai_pll = {
+	.type = PLL_1443X,
+	.rate_table = imx_blk_ctrl_sai_pll_tbl,
+	.rate_count = ARRAY_SIZE(imx_blk_ctrl_sai_pll_tbl),
+};
+
+static const char *imx_sai_mclk2_sels[] = {"sai1_root", "sai2_root", "sai3_root", "dummy",
+					   "sai5_root", "sai6_root", "sai7_root", "sai1_mclk",
+					   "sai2_mclk", "sai3_mclk", "dummy",
+					   "sai5_mclk", "sai6_mclk", "sai7_mclk", "spdif1_ext_clk"};
+static const char *imx_sai1_mclk1_sels[] = {"sai1_root", "sai1_mclk", };
+static const char *imx_sai2_mclk1_sels[] = {"sai2_root", "sai2_mclk", };
+static const char *imx_sai3_mclk1_sels[] = {"sai3_root", "sai3_mclk", };
+static const char *imx_sai5_mclk1_sels[] = {"sai5_root", "sai5_mclk", };
+static const char *imx_sai6_mclk1_sels[] = {"sai6_root", "sai6_mclk", };
+static const char *imx_sai7_mclk1_sels[] = {"sai7_root", "sai7_mclk", };
+static const char *imx_pdm_sels[] = {"pdm_root", "sai_pll_div2", "dummy", "dummy" };
+static const char *imx_sai_pll_ref_sels[] = {"osc_24m", "dummy", "dummy", "dummy", };
+static const char *imx_sai_pll_bypass_sels[] = {"sai_pll", "sai_pll_ref_sel", };
+
+static const char *imx_hdmi_phy_clks_sels[] = { "hdmi_glb_24m", "dummy",};
+static const char *imx_lcdif_clks_sels[] = { "dummy", "hdmi_glb_pix", };
+static const char *imx_hdmi_pipe_clks_sels[] = {"dummy","hdmi_glb_pix", };
+
+static struct imx_blk_ctrl_hw imx8mp_hdmi_blk_ctrl_hws[] = {
+	/* clocks */
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_apb", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_APB_CLK, 0x40, 0, "hdmi_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_b", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_B_CLK, 0x40, 1, "hdmi_axi"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_ref_266m", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_REF266M_CLK, 0x40, 2, "hdmi_ref_266m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_24m", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK, 0x40, 4, "hdmi_24m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_32k", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL32K_CLK, 0x40, 5, "osc_32k"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_glb_pix", IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_TX_PIX_CLK, 0x40, 7, "hdmi_phy"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_irq_steer", IMX8MP_CLK_HDMI_BLK_CTRL_IRQS_STEER_CLK, 0x40, 9, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_noc", IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDMI_CLK, 0x40, 10, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdcp_noc", IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDCP_CLK, 0x40, 11,  "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_apb", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_APB_CLK, 0x40, 16, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_b", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_B_CLK, 0x40, 17, "hdmi_glb_b"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_pdi", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PDI_CLK, 0x40, 18, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_pxl", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PIX_CLK, 0x40, 19, "hdmi_glb_pix"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif3_spu", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_SPU_CLK, 0x40, 20, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_fdcc_ref", IMX8MP_CLK_HDMI_BLK_CTRL_FDCC_REF_CLK, 0x50, 2, "hdmi_fdcc_tst"),
+	IMX_BLK_CTRL_CLK_GATE("hrv_mwr_apb", IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_APB_CLK, 0x50, 3, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hrv_mwr_b", IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_B_CLK, 0x50, 4, "hdmi_glb_axi"),
+	IMX_BLK_CTRL_CLK_GATE("hrv_mwr_cea", IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_CEA_CLK, 0x50, 5, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("vsfd_cea", IMX8MP_CLK_HDMI_BLK_CTRL_VSFD_CEA_CLK, 0x50, 6, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_hpi", IMX8MP_CLK_HDMI_BLK_CTRL_TX_HPI_CLK, 0x50, 13, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_apb", IMX8MP_CLK_HDMI_BLK_CTRL_TX_APB_CLK, 0x50, 14, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_cec", IMX8MP_CLK_HDMI_BLK_CTRL_TX_CEC_CLK, 0x50, 15, "hdmi_glb_32k"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_esm", IMX8MP_CLK_HDMI_BLK_CTRL_TX_ESM_CLK, 0x50, 16, "hdmi_glb_ref_266m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_gpa", IMX8MP_CLK_HDMI_BLK_CTRL_TX_GPA_CLK, 0x50, 17, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_pix", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIXEL_CLK, 0x50, 18, "hdmi_glb_pix"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_sfr", IMX8MP_CLK_HDMI_BLK_CTRL_TX_SFR_CLK, 0x50, 19, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_skp", IMX8MP_CLK_HDMI_BLK_CTRL_TX_SKP_CLK, 0x50, 20, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_tx_prep", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PREP_CLK, 0x50, 21, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_phy_apb", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_APB_CLK, 0x50, 22, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_phy_int", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_INT_CLK, 0x50, 24, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_sec_mem", IMX8MP_CLK_HDMI_BLK_CTRL_TX_SEC_MEM_CLK, 0x50, 25, "hdmi_glb_ref_266m"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_trng_skp", IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_SKP_CLK, 0x50, 27, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_vid_pix",  IMX8MP_CLK_HDMI_BLK_CTRL_TX_VID_LINK_PIX_CLK, 0x50, 28, "hdmi_glb_pix"),
+	IMX_BLK_CTRL_CLK_GATE("hdmi_trng_apb", IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_APB_CLK, 0x50, 30, "hdmi_glb_apb"),
+	IMX_BLK_CTRL_CLK_MUX("hdmi_phy_sel", IMX8MP_CLK_HDMI_BLK_CTRL_HTXPHY_CLK_SEL, 0x50, 10, 1, imx_hdmi_phy_clks_sels),
+	IMX_BLK_CTRL_CLK_MUX("lcdif_clk_sel", IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_CLK_SEL, 0x50, 11, 1, imx_lcdif_clks_sels),
+	IMX_BLK_CTRL_CLK_MUX("hdmi_pipe_sel", IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIPE_CLK_SEL, 0x50, 12, 1, imx_hdmi_pipe_clks_sels),
+
+	/* resets */
+	IMX_BLK_CTRL_RESET_MASK(IMX8MP_HDMI_BLK_CTRL_HDMI_TX_RESET, 0x20, 6, 0x33),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_PHY_RESET, 0x20, 12),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_PAI_RESET, 0x20, 18),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_PAI_RESET, 0x20, 22),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_TRNG_RESET, 0x20, 20),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_IRQ_STEER_RESET, 0x20, 16),
+	IMX_BLK_CTRL_RESET(IMX8MP_HDMI_BLK_CTRL_HDMI_HDCP_RESET, 0x20, 13),
+	IMX_BLK_CTRL_RESET_MASK(IMX8MP_HDMI_BLK_CTRL_LCDIF_RESET, 0x20, 4, 0x3),
+};
+
+static struct imx_blk_ctrl_hw imx8mp_media_blk_ctrl_hws[] = {
+	/* clocks */
+	IMX_BLK_CTRL_CLK_GATE("mipi_dsi_pclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_PCLK, 0x4, 0, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_dsi_clkref", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_CLKREF, 0x4, 1, "media_mipi_phy1_ref"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi_pclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_PCLK, 0x4, 2, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi_aclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_ACLK, 0x4, 3, "media_cam1_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif_pixel_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_PIXEL, 0x4, 4, "media_disp1_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif_apb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_APB, 0x4, 5, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isi_proc_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC, 0x4, 6, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isi_apb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB, 0x4, 7, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi2_pclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_PCLK, 0x4, 9, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_csi2_aclk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_ACLK, 0x4, 10, "media_cam2_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif2_pixel_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_PIXEL, 0x4, 11, "media_disp2_pix_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif2_apb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_APB, 0x4, 12, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isp_cor_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR, 0x4, 16, "media_isp_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isp_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI, 0x4, 17, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("isp_ahb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB, 0x4, 18, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("dwe_cor_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_COR, 0x4, 19, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("dwe_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AXI, 0x4, 20, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("dwe_ahb_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AHB, 0x4, 21, "media_apb_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("mipi_dsi2_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI2, 0x4, 22, "media_mipi_phy1_ref"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_AXI, 0x4, 23, "media_axi_root_clk"),
+	IMX_BLK_CTRL_CLK_GATE("lcdif2_axi_clk", IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_AXI, 0x4, 24, "media_axi_root_clk"),
+
+	/* resets */
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_PCLK, 0, 0),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_CLKREF, 0, 1),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_PCLK, 0, 2),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_ACLK, 0, 3),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_PIXEL, 0, 4),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_APB, 0, 5),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_PROC, 0, 6),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_APB, 0, 7),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_BUS_BLK, 0, 8),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_PCLK, 0, 9),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_ACLK, 0, 10),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_PIXEL, 0, 11),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_APB, 0, 12),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_COR, 0, 13),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AXI, 0, 14),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AHB, 0, 15),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_COR, 0, 16),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AXI, 0, 17),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AHB, 0, 18),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_COR, 0, 19),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AXI, 0, 20),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AHB, 0, 21),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI2, 0, 22),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_AXI, 0, 23),
+	IMX_BLK_CTRL_RESET(IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_AXI, 0, 24)
+};
+
+static struct imx_blk_ctrl_hw imx8mp_audio_blk_ctrl_hws[] = {
+	/* clocks */
+	IMX_BLK_CTRL_CLK_MUX("sai_pll_ref_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_REF_SEL, 0x400, 0, 2, imx_sai_pll_ref_sels),
+	IMX_BLK_CTRL_CLK_PLL14XX("sai_pll", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL, 0x400, "sai_pll_ref_sel", &imx_blk_ctrl_sai_pll),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai_pll_bypass", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_BYPASS, 0x400, 4, 1, imx_sai_pll_bypass_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_GATE("sai_pll_out", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_OUT, 0x400, 13, "sai_pll_bypass"),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai1_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1_SEL, 0x300, 0, 1, imx_sai1_mclk1_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_MUX("sai1_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2_SEL, 0x300, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai2_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1_SEL, 0x304, 0, 1, imx_sai2_mclk1_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_MUX("sai2_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2_SEL, 0x304, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("sai3_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1_SEL, 0x308, 0, 1, imx_sai3_mclk1_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_MUX("sai3_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2_SEL, 0x308, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai5_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1_SEL, 0x30C, 0, 1, imx_sai5_mclk1_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai5_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2_SEL, 0x30C, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai6_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1_SEL, 0x310, 0, 1, imx_sai6_mclk1_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai6_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2_SEL, 0x310, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai7_mclk1_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1_SEL, 0x314, 0, 1, imx_sai7_mclk1_sels),
+	IMX_BLK_CTRL_CLK_MUX("sai7_mclk2_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2_SEL, 0x314, 1, 4, imx_sai_mclk2_sels),
+	IMX_BLK_CTRL_CLK_MUX_FLAGS("pdm_sel", IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_SEL, 0x318, 0, 2, imx_pdm_sels, CLK_SET_RATE_PARENT),
+	IMX_BLK_CTRL_CLK_GATE("sai1_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_IPG, 0, 0, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai1_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1, 0, 1, "sai1_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai1_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2, 0, 2, "sai1_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai1_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK3, 0, 3, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_IPG, 0, 4, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1, 0, 5, "sai2_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2, 0, 6, "sai2_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai2_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK3, 0, 7, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_IPG, 0, 8, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1, 0, 9, "sai3_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2, 0, 10, "sai3_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai3_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK3, 0, 11, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_IPG, 0, 12, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1, 0, 13, "sai5_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2, 0, 14, "sai5_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai5_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK3, 0, 15, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_IPG, 0, 16, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1, 0, 17, "sai6_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2, 0, 18, "sai6_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai6_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK3, 0, 19, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_IPG, 0, 20, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_mclk1_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1, 0, 21, "sai7_mclk1_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_mclk2_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2, 0, 22, "sai7_mclk2_sel"),
+	IMX_BLK_CTRL_CLK_GATE("sai7_mclk3_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK3, 0, 23, "sai_pll_out"),
+	IMX_BLK_CTRL_CLK_GATE("asrc_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_ASRC_IPG, 0, 24, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_SHARED_GATE("pdm_ipg_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_IPG, 0, 25, "audio_ahb_root", &shared_count_pdm),
+	IMX_BLK_CTRL_CLK_SHARED_GATE("pdm_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_ROOT, 0, 25, "pdm_sel", &shared_count_pdm),
+	IMX_BLK_CTRL_CLK_GATE("sdma3_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT, 0, 27, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("spba2_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_SPBA2_ROOT, 0, 28, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("dsp_root_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_DSP_ROOT, 0, 29, "audio_axi_root"),
+	IMX_BLK_CTRL_CLK_GATE("dsp_dbg_clk",    IMX8MP_CLK_AUDIO_BLK_CTRL_DSPDBG_ROOT, 0, 30, "audio_axi_root"),
+	IMX_BLK_CTRL_CLK_GATE("earc_ipg_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_IPG, 0, 31, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("ocram_a_ipg_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_OCRAMA_IPG, 4, 0, "audio_axi_root"),
+	IMX_BLK_CTRL_CLK_GATE("aud2htx_ipg_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_AUD2HTX_IPG, 4, 1, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("edma_root_clk",   IMX8MP_CLK_AUDIO_BLK_CTRL_EDMA_ROOT, 4, 2, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("aud_pll_clk",  IMX8MP_CLK_AUDIO_BLK_CTRL_AUDPLL_ROOT, 4, 3, "osc_24m"),
+	IMX_BLK_CTRL_CLK_GATE("mu2_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_MU2_ROOT, 4, 4, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("mu3_root_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_MU3_ROOT, 4, 5, "audio_ahb_root"),
+	IMX_BLK_CTRL_CLK_GATE("earc_phy_clk", IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_PHY, 4, 6, "sai_pll_out"),
+
+	/* resets */
+	IMX_BLK_CTRL_RESET(IMX8MP_AUDIO_BLK_CTRL_EARC_RESET, 0x200, 0),
+	IMX_BLK_CTRL_RESET(IMX8MP_AUDIO_BLK_CTRL_EARC_PHY_RESET, 0x200, 1),
+};
+
+const struct imx_blk_ctrl_dev_data imx8mp_hdmi_blk_ctrl_dev_data __initconst = {
+	.hws = imx8mp_hdmi_blk_ctrl_hws,
+	.hws_num = ARRAY_SIZE(imx8mp_hdmi_blk_ctrl_hws),
+	.clocks_max = IMX8MP_CLK_HDMI_BLK_CTRL_END,
+	.resets_max = IMX8MP_HDMI_BLK_CTRL_RESET_NUM,
+	.pm_runtime_saved_regs_num = 0
+};
+
+const struct imx_blk_ctrl_dev_data imx8mp_media_blk_ctrl_dev_data __initconst = {
+	.hws = imx8mp_media_blk_ctrl_hws,
+	.hws_num = ARRAY_SIZE(imx8mp_media_blk_ctrl_hws),
+	.clocks_max = IMX8MP_CLK_MEDIA_BLK_CTRL_END,
+	.resets_max = IMX8MP_MEDIA_BLK_CTRL_RESET_NUM,
+	.pm_runtime_saved_regs_num = 2,
+	.pm_runtime_saved_regs = {
+		IMX_MEDIA_BLK_CTRL_SFT_RSTN,
+		IMX_MEDIA_BLK_CTRL_CLK_EN,
+	},
+};
+
+const struct imx_blk_ctrl_dev_data imx8mp_audio_blk_ctrl_dev_data __initconst = {
+	.hws = imx8mp_audio_blk_ctrl_hws,
+	.hws_num = ARRAY_SIZE(imx8mp_audio_blk_ctrl_hws),
+	.clocks_max = IMX8MP_CLK_AUDIO_BLK_CTRL_END,
+	.resets_max = IMX8MP_AUDIO_BLK_CTRL_RESET_NUM,
+	.pm_runtime_saved_regs_num = 16,
+	.pm_runtime_saved_regs = {
+		IMX_AUDIO_BLK_CTRL_CLKEN0,
+		IMX_AUDIO_BLK_CTRL_CLKEN1,
+		IMX_AUDIO_BLK_CTRL_EARC,
+		IMX_AUDIO_BLK_CTRL_SAI1_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI2_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI3_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI5_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI6_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_SAI7_MCLK_SEL,
+		IMX_AUDIO_BLK_CTRL_PDM_CLK,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_GNRL_CTL,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL0,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_FDIVL_CTL1,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_SSCG_CTL,
+		IMX_AUDIO_BLK_CTRL_SAI_PLL_MNIT_CTL,
+		IMX_AUDIO_BLK_CTRL_IPG_LP_CTRL
+	},
+};
 
 static const char * const pll_ref_sels[] = { "osc_24m", "dummy", "dummy", "dummy", };
 static const char * const audio_pll1_bypass_sels[] = {"audio_pll1", "audio_pll1_ref_sel", };
@@ -128,6 +406,10 @@ static const char * const imx8mp_mipi_dsi_esc_rx_sels[] = {"osc_24m", "sys_pll2_
 							   "sys_pll1_800m", "sys_pll2_1000m",
 							   "sys_pll3_out", "clk_ext3", "audio_pll2_out", };
 
+static const char * const imx8mp_media_disp2_pix_sels[] = {"osc_24m", "video_pll1_out", "audio_pll2_out",
+							   "audio_pll1_out", "sys_pll1_800m", "sys_pll2_1000m",
+							   "sys_pll3_out", "clk_ext4", };
+
 static const char * const imx8mp_dram_alt_sels[] = {"osc_24m", "sys_pll1_800m", "sys_pll1_100m",
 						    "sys_pll2_500m", "sys_pll2_1000m", "sys_pll3_out",
 						    "audio_pll1_out", "sys_pll1_266m", };
@@ -152,10 +434,6 @@ static const char * const imx8mp_can2_sels[] = {"osc_24m", "sys_pll2_200m", "sys
 						"sys_pll1_160m", "sys_pll1_800m", "sys_pll3_out",
 						"sys_pll2_250m", "audio_pll2_out", };
 
-static const char * const imx8mp_pcie_phy_sels[] = {"osc_24m", "sys_pll2_100m", "sys_pll2_500m",
-						    "clk_ext1", "clk_ext2", "clk_ext3",
-						    "clk_ext4", "sys_pll1_400m", };
-
 static const char * const imx8mp_pcie_aux_sels[] = {"osc_24m", "sys_pll2_200m", "sys_pll2_50m",
 						    "sys_pll3_out", "sys_pll2_100m", "sys_pll1_80m",
 						    "sys_pll1_160m", "sys_pll1_200m", };
@@ -414,12 +692,42 @@ static const char * const imx8mp_dram_core_sels[] = {"dram_pll_out", "dram_alt_r
 static struct clk_hw **hws;
 static struct clk_hw_onecell_data *clk_hw_data;
 
+static int imx_clk_init_on(struct device_node *np,
+				  struct clk_hw * const clks[])
+{
+	u32 *array;
+	int i, ret, elems;
+
+	elems = of_property_count_u32_elems(np, "init-on-array");
+	if (elems < 0)
+		return elems;
+	array = kcalloc(elems, sizeof(elems), GFP_KERNEL);
+	if (!array)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "init-on-array", array, elems);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < elems; i++) {
+		ret = clk_prepare_enable(clks[array[i]]->clk);
+		if (ret)
+			pr_err("clk_prepare_enable failed %d\n", array[i]);
+	}
+
+	kfree(array);
+
+	return 0;
+}
+
 static int imx8mp_clocks_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 	void __iomem *anatop_base, *ccm_base;
 
+	check_m4_enabled();
+
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx8mp-anatop");
 	anatop_base = of_iomap(np, 0);
 	of_node_put(np);
@@ -492,44 +800,28 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_ARM_PLL_OUT] = imx_clk_hw_gate("arm_pll_out", "arm_pll_bypass", anatop_base + 0x84, 11);
 	hws[IMX8MP_SYS_PLL3_OUT] = imx_clk_hw_gate("sys_pll3_out", "sys_pll3_bypass", anatop_base + 0x114, 11);
 
-	hws[IMX8MP_SYS_PLL1_40M_CG] = imx_clk_hw_gate("sys_pll1_40m_cg", "sys_pll1_bypass", anatop_base + 0x94, 27);
-	hws[IMX8MP_SYS_PLL1_80M_CG] = imx_clk_hw_gate("sys_pll1_80m_cg", "sys_pll1_bypass", anatop_base + 0x94, 25);
-	hws[IMX8MP_SYS_PLL1_100M_CG] = imx_clk_hw_gate("sys_pll1_100m_cg", "sys_pll1_bypass", anatop_base + 0x94, 23);
-	hws[IMX8MP_SYS_PLL1_133M_CG] = imx_clk_hw_gate("sys_pll1_133m_cg", "sys_pll1_bypass", anatop_base + 0x94, 21);
-	hws[IMX8MP_SYS_PLL1_160M_CG] = imx_clk_hw_gate("sys_pll1_160m_cg", "sys_pll1_bypass", anatop_base + 0x94, 19);
-	hws[IMX8MP_SYS_PLL1_200M_CG] = imx_clk_hw_gate("sys_pll1_200m_cg", "sys_pll1_bypass", anatop_base + 0x94, 17);
-	hws[IMX8MP_SYS_PLL1_266M_CG] = imx_clk_hw_gate("sys_pll1_266m_cg", "sys_pll1_bypass", anatop_base + 0x94, 15);
-	hws[IMX8MP_SYS_PLL1_400M_CG] = imx_clk_hw_gate("sys_pll1_400m_cg", "sys_pll1_bypass", anatop_base + 0x94, 13);
 	hws[IMX8MP_SYS_PLL1_OUT] = imx_clk_hw_gate("sys_pll1_out", "sys_pll1_bypass", anatop_base + 0x94, 11);
 
-	hws[IMX8MP_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_40m_cg", 1, 20);
-	hws[IMX8MP_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_80m_cg", 1, 10);
-	hws[IMX8MP_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_100m_cg", 1, 8);
-	hws[IMX8MP_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_133m_cg", 1, 6);
-	hws[IMX8MP_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_160m_cg", 1, 5);
-	hws[IMX8MP_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_200m_cg", 1, 4);
-	hws[IMX8MP_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_266m_cg", 1, 3);
-	hws[IMX8MP_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_400m_cg", 1, 2);
+	hws[IMX8MP_SYS_PLL1_40M] = imx_clk_hw_fixed_factor("sys_pll1_40m", "sys_pll1_out", 1, 20);
+	hws[IMX8MP_SYS_PLL1_80M] = imx_clk_hw_fixed_factor("sys_pll1_80m", "sys_pll1_out", 1, 10);
+	hws[IMX8MP_SYS_PLL1_100M] = imx_clk_hw_fixed_factor("sys_pll1_100m", "sys_pll1_out", 1, 8);
+	hws[IMX8MP_SYS_PLL1_133M] = imx_clk_hw_fixed_factor("sys_pll1_133m", "sys_pll1_out", 1, 6);
+	hws[IMX8MP_SYS_PLL1_160M] = imx_clk_hw_fixed_factor("sys_pll1_160m", "sys_pll1_out", 1, 5);
+	hws[IMX8MP_SYS_PLL1_200M] = imx_clk_hw_fixed_factor("sys_pll1_200m", "sys_pll1_out", 1, 4);
+	hws[IMX8MP_SYS_PLL1_266M] = imx_clk_hw_fixed_factor("sys_pll1_266m", "sys_pll1_out", 1, 3);
+	hws[IMX8MP_SYS_PLL1_400M] = imx_clk_hw_fixed_factor("sys_pll1_400m", "sys_pll1_out", 1, 2);
 	hws[IMX8MP_SYS_PLL1_800M] = imx_clk_hw_fixed_factor("sys_pll1_800m", "sys_pll1_out", 1, 1);
 
-	hws[IMX8MP_SYS_PLL2_50M_CG] = imx_clk_hw_gate("sys_pll2_50m_cg", "sys_pll2_bypass", anatop_base + 0x104, 27);
-	hws[IMX8MP_SYS_PLL2_100M_CG] = imx_clk_hw_gate("sys_pll2_100m_cg", "sys_pll2_bypass", anatop_base + 0x104, 25);
-	hws[IMX8MP_SYS_PLL2_125M_CG] = imx_clk_hw_gate("sys_pll2_125m_cg", "sys_pll2_bypass", anatop_base + 0x104, 23);
-	hws[IMX8MP_SYS_PLL2_166M_CG] = imx_clk_hw_gate("sys_pll2_166m_cg", "sys_pll2_bypass", anatop_base + 0x104, 21);
-	hws[IMX8MP_SYS_PLL2_200M_CG] = imx_clk_hw_gate("sys_pll2_200m_cg", "sys_pll2_bypass", anatop_base + 0x104, 19);
-	hws[IMX8MP_SYS_PLL2_250M_CG] = imx_clk_hw_gate("sys_pll2_250m_cg", "sys_pll2_bypass", anatop_base + 0x104, 17);
-	hws[IMX8MP_SYS_PLL2_333M_CG] = imx_clk_hw_gate("sys_pll2_333m_cg", "sys_pll2_bypass", anatop_base + 0x104, 15);
-	hws[IMX8MP_SYS_PLL2_500M_CG] = imx_clk_hw_gate("sys_pll2_500m_cg", "sys_pll2_bypass", anatop_base + 0x104, 13);
 	hws[IMX8MP_SYS_PLL2_OUT] = imx_clk_hw_gate("sys_pll2_out", "sys_pll2_bypass", anatop_base + 0x104, 11);
 
-	hws[IMX8MP_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_50m_cg", 1, 20);
-	hws[IMX8MP_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_100m_cg", 1, 10);
-	hws[IMX8MP_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_125m_cg", 1, 8);
-	hws[IMX8MP_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_166m_cg", 1, 6);
-	hws[IMX8MP_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_200m_cg", 1, 5);
-	hws[IMX8MP_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_250m_cg", 1, 4);
-	hws[IMX8MP_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_333m_cg", 1, 3);
-	hws[IMX8MP_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_500m_cg", 1, 2);
+	hws[IMX8MP_SYS_PLL2_50M] = imx_clk_hw_fixed_factor("sys_pll2_50m", "sys_pll2_out", 1, 20);
+	hws[IMX8MP_SYS_PLL2_100M] = imx_clk_hw_fixed_factor("sys_pll2_100m", "sys_pll2_out", 1, 10);
+	hws[IMX8MP_SYS_PLL2_125M] = imx_clk_hw_fixed_factor("sys_pll2_125m", "sys_pll2_out", 1, 8);
+	hws[IMX8MP_SYS_PLL2_166M] = imx_clk_hw_fixed_factor("sys_pll2_166m", "sys_pll2_out", 1, 6);
+	hws[IMX8MP_SYS_PLL2_200M] = imx_clk_hw_fixed_factor("sys_pll2_200m", "sys_pll2_out", 1, 5);
+	hws[IMX8MP_SYS_PLL2_250M] = imx_clk_hw_fixed_factor("sys_pll2_250m", "sys_pll2_out", 1, 4);
+	hws[IMX8MP_SYS_PLL2_333M] = imx_clk_hw_fixed_factor("sys_pll2_333m", "sys_pll2_out", 1, 3);
+	hws[IMX8MP_SYS_PLL2_500M] = imx_clk_hw_fixed_factor("sys_pll2_500m", "sys_pll2_out", 1, 2);
 	hws[IMX8MP_SYS_PLL2_1000M] = imx_clk_hw_fixed_factor("sys_pll2_1000m", "sys_pll2_out", 1, 1);
 
 	hws[IMX8MP_CLK_A53_DIV] = imx8m_clk_hw_composite_core("arm_a53_div", imx8mp_a53_sels, ccm_base + 0x8000);
@@ -550,7 +842,7 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 
 	hws[IMX8MP_CLK_MAIN_AXI] = imx8m_clk_hw_composite_bus_critical("main_axi", imx8mp_main_axi_sels, ccm_base + 0x8800);
 	hws[IMX8MP_CLK_ENET_AXI] = imx8m_clk_hw_composite_bus("enet_axi", imx8mp_enet_axi_sels, ccm_base + 0x8880);
-	hws[IMX8MP_CLK_NAND_USDHC_BUS] = imx8m_clk_hw_composite_bus_critical("nand_usdhc_bus", imx8mp_nand_usdhc_sels, ccm_base + 0x8900);
+	hws[IMX8MP_CLK_NAND_USDHC_BUS] = imx8m_clk_hw_composite("nand_usdhc_bus", imx8mp_nand_usdhc_sels, ccm_base + 0x8900);
 	hws[IMX8MP_CLK_VPU_BUS] = imx8m_clk_hw_composite_bus("vpu_bus", imx8mp_vpu_bus_sels, ccm_base + 0x8980);
 	hws[IMX8MP_CLK_MEDIA_AXI] = imx8m_clk_hw_composite_bus("media_axi", imx8mp_media_axi_sels, ccm_base + 0x8a00);
 	hws[IMX8MP_CLK_MEDIA_APB] = imx8m_clk_hw_composite_bus("media_apb", imx8mp_media_apb_sels, ccm_base + 0x8a80);
@@ -566,9 +858,9 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_AHB] = imx8m_clk_hw_composite_bus_critical("ahb_root", imx8mp_ahb_sels, ccm_base + 0x9000);
 	hws[IMX8MP_CLK_AUDIO_AHB] = imx8m_clk_hw_composite_bus("audio_ahb", imx8mp_audio_ahb_sels, ccm_base + 0x9100);
 	hws[IMX8MP_CLK_MIPI_DSI_ESC_RX] = imx8m_clk_hw_composite_bus("mipi_dsi_esc_rx", imx8mp_mipi_dsi_esc_rx_sels, ccm_base + 0x9200);
+	hws[IMX8MP_CLK_MEDIA_DISP2_PIX] = imx8m_clk_hw_composite_bus("media_disp2_pix", imx8mp_media_disp2_pix_sels, ccm_base + 0x9300);
 
 	hws[IMX8MP_CLK_IPG_ROOT] = imx_clk_hw_divider2("ipg_root", "ahb_root", ccm_base + 0x9080, 0, 1);
-	hws[IMX8MP_CLK_IPG_AUDIO_ROOT] = imx_clk_hw_divider2("ipg_audio_root", "audio_ahb", ccm_base + 0x9180, 0, 1);
 
 	hws[IMX8MP_CLK_DRAM_ALT] = imx8m_clk_hw_composite("dram_alt", imx8mp_dram_alt_sels, ccm_base + 0xa000);
 	hws[IMX8MP_CLK_DRAM_APB] = imx8m_clk_hw_composite_critical("dram_apb", imx8mp_dram_apb_sels, ccm_base + 0xa080);
@@ -576,7 +868,6 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_VPU_G2] = imx8m_clk_hw_composite("vpu_g2", imx8mp_vpu_g2_sels, ccm_base + 0xa180);
 	hws[IMX8MP_CLK_CAN1] = imx8m_clk_hw_composite("can1", imx8mp_can1_sels, ccm_base + 0xa200);
 	hws[IMX8MP_CLK_CAN2] = imx8m_clk_hw_composite("can2", imx8mp_can2_sels, ccm_base + 0xa280);
-	hws[IMX8MP_CLK_PCIE_PHY] = imx8m_clk_hw_composite("pcie_phy", imx8mp_pcie_phy_sels, ccm_base + 0xa380);
 	hws[IMX8MP_CLK_PCIE_AUX] = imx8m_clk_hw_composite("pcie_aux", imx8mp_pcie_aux_sels, ccm_base + 0xa400);
 	hws[IMX8MP_CLK_I2C5] = imx8m_clk_hw_composite("i2c5", imx8mp_i2c5_sels, ccm_base + 0xa480);
 	hws[IMX8MP_CLK_I2C6] = imx8m_clk_hw_composite("i2c6", imx8mp_i2c6_sels, ccm_base + 0xa500);
@@ -686,7 +977,7 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_SIM_ENET_ROOT] = imx_clk_hw_gate4("sim_enet_root_clk", "enet_axi", ccm_base + 0x4400, 0);
 	hws[IMX8MP_CLK_GPU2D_ROOT] = imx_clk_hw_gate4("gpu2d_root_clk", "gpu2d_core", ccm_base + 0x4450, 0);
 	hws[IMX8MP_CLK_GPU3D_ROOT] = imx_clk_hw_gate4("gpu3d_root_clk", "gpu3d_core", ccm_base + 0x4460, 0);
-	hws[IMX8MP_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", ccm_base + 0x4470, 0);
+	hws[IMX8MP_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", ccm_base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MP_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", ccm_base + 0x4490, 0);
 	hws[IMX8MP_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", ccm_base + 0x44a0, 0);
 	hws[IMX8MP_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", ccm_base + 0x44b0, 0);
@@ -710,13 +1001,23 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MP_CLK_MEDIA_CAM2_PIX_ROOT] = imx_clk_hw_gate2_shared2("media_cam2_pix_root_clk", "media_cam2_pix", ccm_base + 0x45d0, 0, &share_count_media);
 	hws[IMX8MP_CLK_MEDIA_DISP1_PIX_ROOT] = imx_clk_hw_gate2_shared2("media_disp1_pix_root_clk", "media_disp1_pix", ccm_base + 0x45d0, 0, &share_count_media);
 	hws[IMX8MP_CLK_MEDIA_DISP2_PIX_ROOT] = imx_clk_hw_gate2_shared2("media_disp2_pix_root_clk", "media_disp2_pix", ccm_base + 0x45d0, 0, &share_count_media);
+	hws[IMX8MP_CLK_MEDIA_LDB_ROOT] = imx_clk_hw_gate2_shared2("media_ldb_root_clk", "media_ldb", ccm_base + 0x45d0, 0, &share_count_media);
 	hws[IMX8MP_CLK_MEDIA_ISP_ROOT] = imx_clk_hw_gate2_shared2("media_isp_root_clk", "media_isp", ccm_base + 0x45d0, 0, &share_count_media);
 
 	hws[IMX8MP_CLK_USDHC3_ROOT] = imx_clk_hw_gate4("usdhc3_root_clk", "usdhc3", ccm_base + 0x45e0, 0);
 	hws[IMX8MP_CLK_HDMI_ROOT] = imx_clk_hw_gate4("hdmi_root_clk", "hdmi_axi", ccm_base + 0x45f0, 0);
 	hws[IMX8MP_CLK_TSENSOR_ROOT] = imx_clk_hw_gate4("tsensor_root_clk", "ipg_root", ccm_base + 0x4620, 0);
 	hws[IMX8MP_CLK_VPU_ROOT] = imx_clk_hw_gate4("vpu_root_clk", "vpu_bus", ccm_base + 0x4630, 0);
-	hws[IMX8MP_CLK_AUDIO_ROOT] = imx_clk_hw_gate4("audio_root_clk", "ipg_root", ccm_base + 0x4650, 0);
+
+	hws[IMX8MP_CLK_AUDIO_AHB_ROOT] = imx_clk_hw_gate2_shared2("audio_ahb_root", "audio_ahb", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_AUDIO_AXI_ROOT] = imx_clk_hw_gate2_shared2("audio_axi_root", "audio_axi", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI1_ROOT] = imx_clk_hw_gate2_shared2("sai1_root", "sai1", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI2_ROOT] = imx_clk_hw_gate2_shared2("sai2_root", "sai2", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI3_ROOT] = imx_clk_hw_gate2_shared2("sai3_root", "sai3", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI5_ROOT] = imx_clk_hw_gate2_shared2("sai5_root", "sai5", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root", "sai6", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_SAI7_ROOT] = imx_clk_hw_gate2_shared2("sai7_root", "sai7", ccm_base + 0x4650, 0, &share_count_audio);
+	hws[IMX8MP_CLK_PDM_ROOT] = imx_clk_hw_gate2_shared2("pdm_root", "pdm", ccm_base + 0x4650, 0, &share_count_audio);
 
 	hws[IMX8MP_CLK_ARM] = imx_clk_hw_cpu("arm", "arm_a53_core",
 					     hws[IMX8MP_CLK_A53_CORE]->clk,
@@ -728,6 +1029,8 @@ static int imx8mp_clocks_probe(struct platform_device *pdev)
 
 	of_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_hw_data);
 
+	imx_clk_init_on(np, hws);
+
 	imx_register_uart_clocks(4);
 
 	return 0;
@@ -756,3 +1059,80 @@ module_platform_driver(imx8mp_clk_driver);
 MODULE_AUTHOR("Anson Huang <Anson.Huang@nxp.com>");
 MODULE_DESCRIPTION("NXP i.MX8MP clock driver");
 MODULE_LICENSE("GPL v2");
+
+#ifndef MODULE
+/*
+ * Debugfs interface for audio PLL K divider change dynamically.
+ * Monitor control for the Audio PLL K-Divider
+ */
+#ifdef CONFIG_DEBUG_FS
+
+#define KDIV_MASK	GENMASK(15, 0)
+#define MDIV_SHIFT	12
+#define MDIV_MASK	GENMASK(21, 12)
+#define PDIV_SHIFT	4
+#define PDIV_MASK	GENMASK(9, 4)
+#define SDIV_SHIFT	0
+#define SDIV_MASK	GENMASK(2, 0)
+
+static int pll_delta_k_set(void *data, u64 val)
+{
+	struct clk_hw *hw;
+	short int delta_k;
+
+	hw = data;
+	delta_k = (short int) (val & KDIV_MASK);
+
+	clk_set_delta_k(hw, val);
+
+	pr_debug("the delta k is %d\n", delta_k);
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(delta_k_fops, NULL, pll_delta_k_set, "%lld\n");
+
+static int pll_setting_show(struct seq_file *s, void *data)
+{
+	struct clk_hw *hw;
+	u32 pll_div_ctrl0, pll_div_ctrl1;
+	u32 mdiv, pdiv, sdiv, kdiv;
+
+	hw = s->private;
+
+	clk_get_pll_setting(hw, &pll_div_ctrl0, &pll_div_ctrl1);
+	mdiv = (pll_div_ctrl0 & MDIV_MASK) >> MDIV_SHIFT;
+	pdiv = (pll_div_ctrl0 & PDIV_MASK) >> PDIV_SHIFT;
+	sdiv = (pll_div_ctrl0 & SDIV_MASK) >> SDIV_SHIFT;
+	kdiv = (pll_div_ctrl1 & KDIV_MASK);
+
+	seq_printf(s, "Mdiv: 0x%x; Pdiv: 0x%x; Sdiv: 0x%x; Kdiv: 0x%x\n",
+		mdiv, pdiv, sdiv, kdiv);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(pll_setting);
+
+static int __init pll_debug_init(void)
+{
+	struct dentry *root, *audio_pll1, *audio_pll2;
+
+	if (of_machine_is_compatible("fsl,imx8mp") && hws) {
+		/* create a root dir for audio pll monitor */
+		root = debugfs_create_dir("audio_pll_monitor", NULL);
+		audio_pll1 = debugfs_create_dir("audio_pll1", root);
+		audio_pll2 = debugfs_create_dir("audio_pll2", root);
+
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll1,
+			hws[IMX8MP_AUDIO_PLL1], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll1,
+			hws[IMX8MP_AUDIO_PLL1], &pll_setting_fops);
+		debugfs_create_file_unsafe("delta_k", 0444, audio_pll2,
+			hws[IMX8MP_AUDIO_PLL2], &delta_k_fops);
+		debugfs_create_file("pll_parameter", 0x444, audio_pll2,
+			hws[IMX8MP_AUDIO_PLL2], &pll_setting_fops);
+	}
+
+	return 0;
+}
+late_initcall(pll_debug_init);
+#endif /* CONFIG_DEBUG_FS */
+#endif /* MODULE */
diff --git a/drivers/clk/imx/clk-imx8mq.c b/drivers/clk/imx/clk-imx8mq.c
index 4297595712b0..5dfb0059b94b 100644
--- a/drivers/clk/imx/clk-imx8mq.c
+++ b/drivers/clk/imx/clk-imx8mq.c
@@ -535,7 +535,7 @@ static int imx8mq_clocks_probe(struct platform_device *pdev)
 	hws[IMX8MQ_CLK_SAI5_IPG] = imx_clk_hw_gate2_shared2("sai5_ipg_clk", "ipg_audio_root", base + 0x4370, 0, &share_count_sai5);
 	hws[IMX8MQ_CLK_SAI6_ROOT] = imx_clk_hw_gate2_shared2("sai6_root_clk", "sai6", base + 0x4380, 0, &share_count_sai6);
 	hws[IMX8MQ_CLK_SAI6_IPG] = imx_clk_hw_gate2_shared2("sai6_ipg_clk", "ipg_audio_root", base + 0x4380, 0, &share_count_sai6);
-	hws[IMX8MQ_CLK_SNVS_ROOT] = imx_clk_hw_gate4("snvs_root_clk", "ipg_root", base + 0x4470, 0);
+	hws[IMX8MQ_CLK_SNVS_ROOT] = imx_clk_hw_gate2_flags("snvs_root_clk", "ipg_root", base + 0x4470, 0, CLK_IS_CRITICAL);
 	hws[IMX8MQ_CLK_UART1_ROOT] = imx_clk_hw_gate4("uart1_root_clk", "uart1", base + 0x4490, 0);
 	hws[IMX8MQ_CLK_UART2_ROOT] = imx_clk_hw_gate4("uart2_root_clk", "uart2", base + 0x44a0, 0);
 	hws[IMX8MQ_CLK_UART3_ROOT] = imx_clk_hw_gate4("uart3_root_clk", "uart3", base + 0x44b0, 0);
diff --git a/drivers/clk/imx/clk-pll14xx.c b/drivers/clk/imx/clk-pll14xx.c
index aba36e4217d2..2160513942a2 100644
--- a/drivers/clk/imx/clk-pll14xx.c
+++ b/drivers/clk/imx/clk-pll14xx.c
@@ -360,6 +360,26 @@ static void clk_pll14xx_unprepare(struct clk_hw *hw)
 	writel_relaxed(val, pll->base + GNRL_CTL);
 }
 
+void clk_set_delta_k(struct clk_hw *hw, short int delta_k)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+	short int k;
+	u32 val;
+
+	val = readl_relaxed(pll->base + 8);
+	k = (val & KDIV_MASK) + delta_k;
+	writel_relaxed(k << KDIV_SHIFT, pll->base + 8);
+}
+
+void clk_get_pll_setting(struct clk_hw *hw, u32 *pll_div_ctrl0,
+	u32 *pll_div_ctrl1)
+{
+	struct clk_pll14xx *pll = to_clk_pll14xx(hw);
+
+	*pll_div_ctrl0 = readl_relaxed(pll->base + 4);
+	*pll_div_ctrl1 = readl_relaxed(pll->base + 8);
+}
+
 static const struct clk_ops clk_pll1416x_ops = {
 	.prepare	= clk_pll14xx_prepare,
 	.unprepare	= clk_pll14xx_unprepare,
diff --git a/drivers/clk/imx/clk.h b/drivers/clk/imx/clk.h
index c66e00e87711..7f548e77a9b1 100644
--- a/drivers/clk/imx/clk.h
+++ b/drivers/clk/imx/clk.h
@@ -601,4 +601,7 @@ struct clk_hw *imx_clk_hw_divider_gate(const char *name, const char *parent_name
 		unsigned long flags, void __iomem *reg, u8 shift, u8 width,
 		u8 clk_divider_flags, const struct clk_div_table *table,
 		spinlock_t *lock);
+
+void clk_set_delta_k(struct clk_hw *hw, short int delta_k);
+void clk_get_pll_setting(struct clk_hw *hw, u32 *pll_div_ctrl0, u32 *pll_div_ctrl1);
 #endif
diff --git a/include/dt-bindings/clock/imx8mp-clock.h b/include/dt-bindings/clock/imx8mp-clock.h
index e8d68fbb6e3f..875a05380b51 100644
--- a/include/dt-bindings/clock/imx8mp-clock.h
+++ b/include/dt-bindings/clock/imx8mp-clock.h
@@ -322,68 +322,271 @@
 #define IMX8MP_CLK_HSIO_AXI			311
 #define IMX8MP_CLK_MEDIA_ISP			312
 
-#define IMX8MP_CLK_END				313
+#define IMX8MP_CLK_MEDIA_DISP2_PIX		313
+#define IMX8MP_CLK_MEDIA_LDB_ROOT		314
+#define IMX8MP_CLK_AUDIO_AHB_ROOT		315
+#define IMX8MP_CLK_AUDIO_AXI_ROOT		316
+#define IMX8MP_CLK_SAI1_ROOT			317
+#define IMX8MP_CLK_SAI2_ROOT			318
+#define IMX8MP_CLK_SAI3_ROOT			319
+#define IMX8MP_CLK_SAI5_ROOT			320
+#define IMX8MP_CLK_SAI6_ROOT			321
+#define IMX8MP_CLK_SAI7_ROOT			322
+#define IMX8MP_CLK_PDM_ROOT			323
 
-#define IMX8MP_CLK_AUDIOMIX_SAI1_IPG		0
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK1		1
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK2		2
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK3		3
-#define IMX8MP_CLK_AUDIOMIX_SAI2_IPG		4
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK1		5
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK2		6
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK3		7
-#define IMX8MP_CLK_AUDIOMIX_SAI3_IPG		8
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1		9
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK2		10
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK3		11
-#define IMX8MP_CLK_AUDIOMIX_SAI5_IPG		12
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK1		13
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK2		14
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK3		15
-#define IMX8MP_CLK_AUDIOMIX_SAI6_IPG		16
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK1		17
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK2		18
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK3		19
-#define IMX8MP_CLK_AUDIOMIX_SAI7_IPG		20
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK1		21
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK2		22
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK3		23
-#define IMX8MP_CLK_AUDIOMIX_ASRC_IPG		24
-#define IMX8MP_CLK_AUDIOMIX_PDM_IPG		25
-#define IMX8MP_CLK_AUDIOMIX_SDMA2_ROOT		26
-#define IMX8MP_CLK_AUDIOMIX_SDMA3_ROOT		27
-#define IMX8MP_CLK_AUDIOMIX_SPBA2_ROOT		28
-#define IMX8MP_CLK_AUDIOMIX_DSP_ROOT		29
-#define IMX8MP_CLK_AUDIOMIX_DSPDBG_ROOT		30
-#define IMX8MP_CLK_AUDIOMIX_EARC_IPG		31
-#define IMX8MP_CLK_AUDIOMIX_OCRAMA_IPG		32
-#define IMX8MP_CLK_AUDIOMIX_AUD2HTX_IPG		33
-#define IMX8MP_CLK_AUDIOMIX_EDMA_ROOT		34
-#define IMX8MP_CLK_AUDIOMIX_AUDPLL_ROOT		35
-#define IMX8MP_CLK_AUDIOMIX_MU2_ROOT		36
-#define IMX8MP_CLK_AUDIOMIX_MU3_ROOT		37
-#define IMX8MP_CLK_AUDIOMIX_EARC_PHY		38
-#define IMX8MP_CLK_AUDIOMIX_PDM_ROOT		39
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK1_SEL	40
-#define IMX8MP_CLK_AUDIOMIX_SAI1_MCLK2_SEL	41
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK1_SEL	42
-#define IMX8MP_CLK_AUDIOMIX_SAI2_MCLK2_SEL	43
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1_SEL	44
-#define IMX8MP_CLK_AUDIOMIX_SAI3_MCLK2_SEL	45
-#define IMX8MP_CLK_AUDIOMIX_SAI4_MCLK1_SEL	46
-#define IMX8MP_CLK_AUDIOMIX_SAI4_MCLK2_SEL	47
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK1_SEL	48
-#define IMX8MP_CLK_AUDIOMIX_SAI5_MCLK2_SEL	49
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK1_SEL	50
-#define IMX8MP_CLK_AUDIOMIX_SAI6_MCLK2_SEL	51
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK1_SEL	52
-#define IMX8MP_CLK_AUDIOMIX_SAI7_MCLK2_SEL	53
-#define IMX8MP_CLK_AUDIOMIX_PDM_SEL		54
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL_REF_SEL	55
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL		56
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL_BYPASS	57
-#define IMX8MP_CLK_AUDIOMIX_SAI_PLL_OUT		58
+#define IMX8MP_CLK_END				324
 
-#define IMX8MP_CLK_AUDIOMIX_END			59
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_IPG		0
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1		1
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2		2
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK3		3
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_IPG		4
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1		5
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2		6
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK3		7
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_IPG		8
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1		9
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2		10
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK3		11
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_IPG		12
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1		13
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2		14
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK3		15
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_IPG		16
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1		17
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2		18
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK3		19
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_IPG		20
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1		21
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2		22
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK3		23
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_ASRC_IPG		24
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_IPG		25
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA2_ROOT		26
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT		27
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SPBA2_ROOT		28
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_DSP_ROOT		29
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_DSPDBG_ROOT		30
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_IPG		31
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_OCRAMA_IPG		32
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_AUD2HTX_IPG		33
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EDMA_ROOT		34
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_AUDPLL_ROOT		35
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_MU2_ROOT		36
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_MU3_ROOT		37
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_PHY		38
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_ROOT		39
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1_SEL	40
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2_SEL	41
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1_SEL	42
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2_SEL	43
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1_SEL	44
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2_SEL	45
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI4_MCLK1_SEL	46
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI4_MCLK2_SEL	47
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1_SEL	48
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2_SEL	49
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1_SEL	50
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2_SEL	51
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1_SEL	52
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2_SEL	53
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_SEL		54
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_REF_SEL	55
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL		56
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_BYPASS	57
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_OUT		58
+
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_END			59
+
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_APB_CLK		0
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_B_CLK		1
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_REF266M_CLK	2
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK	3
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL32K_CLK	4
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_TX_PIX_CLK	5
+#define IMX8MP_CLK_HDMI_BLK_CTRL_IRQS_STEER_CLK		6
+#define IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDMI_CLK		7
+#define IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDCP_CLK		8
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_APB_CLK		9
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_B_CLK		10
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PDI_CLK		11
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PIX_CLK		12
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_SPU_CLK		13
+#define IMX8MP_CLK_HDMI_BLK_CTRL_FDCC_REF_CLK		14
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_APB_CLK	15
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_B_CLK		16
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_CEA_CLK	17
+#define IMX8MP_CLK_HDMI_BLK_CTRL_VSFD_CEA_CLK		18
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_HPI_CLK		19
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_APB_CLK		20
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_CEC_CLK		21
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_ESM_CLK		22
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_GPA_CLK		23
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIXEL_CLK		24
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SFR_CLK		25
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SKP_CLK		26
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PREP_CLK		27
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_APB_CLK		28
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_INT_CLK		29
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SEC_MEM_CLK		30
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_SKP_CLK	31
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_VID_LINK_PIX_CLK	32
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_APB_CLK	33
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HTXPHY_CLK_SEL		34
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_CLK_SEL		35
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIPE_CLK_SEL	36
+
+#define IMX8MP_CLK_HDMI_BLK_CTRL_END			37
+
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_PCLK		0
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_CLKREF	1
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_PCLK		2
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_ACLK		3
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_PIXEL		4
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_APB		5
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC		6
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB		7
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_BUS_BLK		8
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_PCLK	9
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_ACLK	10
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_PIXEL		11
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_APB		12
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR		16
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI		17
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB		18
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_COR		19
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AXI		20
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AHB		21
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI2		22
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_AXI		23
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_AXI		24
+
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_END			25
+
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_IPG		0
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1		1
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2		2
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK3		3
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_IPG		4
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1		5
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2		6
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK3		7
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_IPG		8
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1		9
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2		10
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK3		11
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_IPG		12
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1		13
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2		14
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK3		15
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_IPG		16
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1		17
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2		18
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK3		19
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_IPG		20
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1		21
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2		22
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK3		23
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_ASRC_IPG		24
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_IPG		25
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SDMA3_ROOT		27
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SPBA2_ROOT		28
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_DSP_ROOT		29
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_DSPDBG_ROOT		30
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_IPG		31
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_OCRAMA_IPG		32
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_AUD2HTX_IPG		33
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EDMA_ROOT		34
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_AUDPLL_ROOT		35
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_MU2_ROOT		36
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_MU3_ROOT		37
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_EARC_PHY		38
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_ROOT		39
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK1_SEL	40
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI1_MCLK2_SEL	41
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK1_SEL	42
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI2_MCLK2_SEL	43
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK1_SEL	44
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI3_MCLK2_SEL	45
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI4_MCLK1_SEL	46
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI4_MCLK2_SEL	47
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK1_SEL	48
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI5_MCLK2_SEL	49
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK1_SEL	50
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI6_MCLK2_SEL	51
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK1_SEL	52
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI7_MCLK2_SEL	53
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_PDM_SEL		54
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_REF_SEL	55
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL		56
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_BYPASS	57
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_SAI_PLL_OUT		58
+
+#define IMX8MP_CLK_AUDIO_BLK_CTRL_END			59
+
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_APB_CLK		0
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_B_CLK		1
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_REF266M_CLK	2
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL24M_CLK	3
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_XTAL32K_CLK	4
+#define IMX8MP_CLK_HDMI_BLK_CTRL_GLOBAL_TX_PIX_CLK	5
+#define IMX8MP_CLK_HDMI_BLK_CTRL_IRQS_STEER_CLK		6
+#define IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDMI_CLK		7
+#define IMX8MP_CLK_HDMI_BLK_CTRL_NOC_HDCP_CLK		8
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_APB_CLK		9
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_B_CLK		10
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PDI_CLK		11
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_PIX_CLK		12
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_SPU_CLK		13
+#define IMX8MP_CLK_HDMI_BLK_CTRL_FDCC_REF_CLK		14
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_APB_CLK	15
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_B_CLK		16
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HRV_MWR_CEA_CLK	17
+#define IMX8MP_CLK_HDMI_BLK_CTRL_VSFD_CEA_CLK		18
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_HPI_CLK		19
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_APB_CLK		20
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_CEC_CLK		21
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_ESM_CLK		22
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_GPA_CLK		23
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIXEL_CLK		24
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SFR_CLK		25
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SKP_CLK		26
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PREP_CLK		27
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_APB_CLK		28
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PHY_INT_CLK		29
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_SEC_MEM_CLK		30
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_SKP_CLK	31
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_VID_LINK_PIX_CLK	32
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_TRNG_APB_CLK	33
+#define IMX8MP_CLK_HDMI_BLK_CTRL_HTXPHY_CLK_SEL		34
+#define IMX8MP_CLK_HDMI_BLK_CTRL_LCDIF_CLK_SEL		35
+#define IMX8MP_CLK_HDMI_BLK_CTRL_TX_PIPE_CLK_SEL	36
+
+#define IMX8MP_CLK_HDMI_BLK_CTRL_END			37
+
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_PCLK		0
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI_CLKREF	1
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_PCLK		2
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI_ACLK		3
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_PIXEL		4
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_APB		5
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_PROC		6
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISI_APB		7
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_BUS_BLK		8
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_PCLK	9
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_CSI2_ACLK	10
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_PIXEL		11
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_APB		12
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_COR		16
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AXI		17
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_ISP_AHB		18
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_COR		19
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AXI		20
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_DWE_AHB		21
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_MIPI_DSI2		22
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF_AXI		23
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_LCDIF2_AXI		24
+
+#define IMX8MP_CLK_MEDIA_BLK_CTRL_END			25
 
 #endif
diff --git a/include/dt-bindings/reset/imx8mp-reset.h b/include/dt-bindings/reset/imx8mp-reset.h
index 2e8c9104b666..113a9a0e8356 100644
--- a/include/dt-bindings/reset/imx8mp-reset.h
+++ b/include/dt-bindings/reset/imx8mp-reset.h
@@ -44,7 +44,53 @@
 #define IMX8MP_RESET_VPU_G2_RESET		35
 #define IMX8MP_RESET_VPUVC8KE_RESET		36
 #define IMX8MP_RESET_NOC_RESET			37
+#define IMX8MP_RESET_PCIE_CTRL_APPS_CLK_REQ	38
+
+#define IMX8MP_RESET_NUM			39
+
+#define IMX8MP_AUDIO_BLK_CTRL_EARC_RESET	0
+#define IMX8MP_AUDIO_BLK_CTRL_EARC_PHY_RESET	1
+
+#define IMX8MP_AUDIO_BLK_CTRL_RESET_NUM		2
+
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_PCLK	0
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI_CLKREF	1
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_PCLK	2
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI_ACLK	3
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_PIXEL		4
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_APB		5
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_PROC		6
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISI_APB		7
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_BUS_BLK		8
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_PCLK	9
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_CSI2_ACLK	10
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_PIXEL	11
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_APB		12
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_COR		13
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AXI		14
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP1_AHB		15
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_COR		16
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AXI		17
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_ISP0_AHB		18
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_COR		19
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AXI		20
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_DWE_AHB		21
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_MIPI_DSI2		22
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF_AXI		23
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_LCDIF2_AXI		24
+
+#define IMX8MP_MEDIA_BLK_CTRL_RESET_NUM			25
+
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_TX_RESET		0
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_PHY_RESET		1
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_PAI_RESET		2
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_PVI_RESET		3
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_TRNG_RESET		4
+#define IMX8MP_HDMI_BLK_CTRL_IRQ_STEER_RESET		5
+#define IMX8MP_HDMI_BLK_CTRL_HDMI_HDCP_RESET		6
+#define IMX8MP_HDMI_BLK_CTRL_LCDIF_RESET		7
+
+#define IMX8MP_HDMI_BLK_CTRL_RESET_NUM			8
 
-#define IMX8MP_RESET_NUM			38
 
 #endif
-- 
2.39.0

