# Copyright (c) 2025, Zededa, Inc.
# SPDX-License-Identifier: Apache-2.0
---
name: Run Eden

on:  # yamllint disable-line rule:truthy
  workflow_run:
    workflows: ["PR Gate"]
    types: [completed]

permissions:
  contents: read
  actions: read
  statuses: write

env:
  EDEN_IN_PR_STATUS_TITLE_PREFIX: Eden Runner
  EDEN_IN_PR_DETAILS_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
  EDEN_PARENT_JOB_TITLE_PREFIX: Eden Tests
  RUN_CONTEXT_FILE: run-context.json

jobs:
  context:
    name: Setup Context from Gate
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      pr_id: ${{ steps.extract.outputs.pr_id }}
      original_run_id: ${{ steps.extract.outputs.original_run_id }}
      pr_sha: ${{ steps.extract.outputs.pr_sha }}
      pr_base_ref: ${{ steps.extract.outputs.pr_base_ref }}
      hv: ${{ steps.extract.outputs.hv }}
      arch: ${{ steps.extract.outputs.arch }}
      platform: ${{ steps.extract.outputs.platform }}
      eden_parent_job_title: ${{ steps.titles.outputs.eden_parent_job_title }}
      eden_in_pr_status_title: ${{ steps.titles.outputs.eden_in_pr_status_title }}
      gate_run_id: ${{ steps.extract.outputs.gate_run_id }}
      gate_status_name: ${{ steps.extract.outputs.gate_status_name }}
      skip_run: ${{ steps.check_gate.outputs.skip_run }}
    steps:
      - name: Download
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: run-context
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if Gate Passed
        id: check_gate
        run: |
          if [[ ! -f "$RUN_CONTEXT_FILE" ]]; then
            echo "::error::Gate context file not found"
            echo "skip_run=true" >> "$GITHUB_OUTPUT"
            exit 1
          fi
          # Check if the file contains only the "exit" command
          if [[ $(cat "$RUN_CONTEXT_FILE") == "exit" ]]; then
            echo "::error::Gate not satisfied, exiting"
            echo "skip_run=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip_run=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Verify
        if: ${{ steps.check_gate.outputs.skip_run == 'false' }}
        env:
          RUN_CONTEXT_FILE: ${{ env.RUN_CONTEXT_FILE }}
          REQUIRED_FIELDS: pr_id, original_run_id, pr_sha, pr_base_ref, hv, arch, platform, gate_run_id, gate_status_name
        run: |
          if [[ ! -f "$RUN_CONTEXT_FILE" ]]; then
            echo "$RUN_CONTEXT_FILE file not found"
            exit 1
          fi
          cat "$RUN_CONTEXT_FILE"
          if ! jq -e . $RUN_CONTEXT_FILE > /dev/null; then
            echo "$RUN_CONTEXT_FILE is not a valid JSON file"
            exit 1
          fi
          # Now check for all required fields
          has_all_fields=true

          # Split the CSV once; spaces in names are not expected, so keep tr
          for field in $(echo "$REQUIRED_FIELDS" | tr ',' ' '); do
            if ! jq -e --arg f "$field" 'has($f)' "$RUN_CONTEXT_FILE" >/dev/null; then
              echo "Missing required field: $field"
              has_all_fields=false
            fi
          done

          if [[ $has_all_fields == false ]]; then
            echo "Run context is missing required fields"
            exit 1
          fi

      - name: Extract
        if: ${{ steps.check_gate.outputs.skip_run == 'false' }}
        id: extract
        env:
          FIELDS: pr_id, original_run_id, pr_sha, pr_base_ref, hv, arch, platform, gate_run_id, gate_status_name
        run: |
          # Extract fields from the JSON file
          for field in $(echo "$FIELDS" | tr ',' ' '); do
            value=$(jq -r --arg f "$field" '.[$f]' $RUN_CONTEXT_FILE)
            if [[ -z "$value" || "$value" == "null" ]]; then
              echo "Field $field is empty or null"
              exit 1
            fi
            echo "$field=$value" >> "$GITHUB_OUTPUT"
          done

      - name: Define Titles
        if: ${{ steps.check_gate.outputs.skip_run == 'false' }}
        id: titles
        run: |
          postfix="(${{ steps.extract.outputs.hv }}, ${{ steps.extract.outputs.arch }}, ${{ steps.extract.outputs.platform }})"
          echo "eden_parent_job_title=${{ env.EDEN_PARENT_JOB_TITLE_PREFIX }} $postfix" >> "$GITHUB_OUTPUT"
          echo "eden_in_pr_status_title=${{ env.EDEN_IN_PR_STATUS_TITLE_PREFIX }} $postfix" >> "$GITHUB_OUTPUT"

  check_secrets:
    name: Check Secrets
    if: github.event.workflow_run.conclusion == 'success' && needs.context.outputs.skip_run == 'false'
    needs: context
    runs-on: ubuntu-latest
    steps:
      - name: Check Dockerhub credentials
        run: |
          if [[ -z "${{ secrets.DOCKERHUB_PULL_USER }}" ]]; then
            echo "Warning: DOCKERHUB_PULL_USER secret is not set. This may affect the ability to pull images from Docker Hub.";
          fi

  status_ui:
    name: Reset & Render Eden statuses
    runs-on: ubuntu-latest
    needs: context
    if: needs.context.outputs.skip_run == 'false'
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      PR_SHA: ${{ needs.context.outputs.pr_sha }}
      EDEN_RUNNER_CTX: ${{ needs.context.outputs.eden_in_pr_status_title }}
      EDEN_TESTS_PREFIX: ${{ needs.context.outputs.eden_parent_job_title }}
      EDEN_DETAILS_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Reset Eden Runner & Eden jobs statuses
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        with:
          script: |
            const { owner, repo } = context.repo;
            const sha = process.env.PR_SHA;

            // Get the current commit statuses for the PR
            const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
              owner, repo, ref: sha
            });

            // Reset the Eden Runner status
            await github.rest.repos.createCommitStatus({
              owner, repo, sha,
              state:       'pending',
              context:     process.env.EDEN_RUNNER_CTX,
              description: 'Eden tests queued…',
              target_url:  process.env.EDEN_DETAILS_URL
            });

            // Reset the Eden tests non-green statuses
            const prefix = `${process.env.EDEN_TESTS_PREFIX} / `;
            for (const s of statuses) {
              if (s.context.startsWith(prefix) && s.state !== 'success') {
                await github.rest.repos.createCommitStatus({
                  owner, repo, sha,
                  state:       'pending',
                  context:     s.context,
                  description: 'Rerunning…',
                  target_url:  process.env.EDEN_DETAILS_URL
                });
              }
            }


  select_eden_version:
    name: Select Eden Version
    runs-on: ubuntu-latest
    needs: context
    if: needs.context.outputs.skip_run == 'false'
    outputs:
      eden_version: ${{ steps.select.outputs.eden_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Select Eden version based on target branch
        id: select
        env:
          BASE_REF: ${{ needs.context.outputs.pr_base_ref }}
        run: |
          MAPPING_FILE=".github/eden-version-map.yml"

          if [[ ! -f "$MAPPING_FILE" ]]; then
            echo "::error::Eden version mapping file not found: $MAPPING_FILE"
            exit 1
          fi

          echo "PR target branch: $BASE_REF"

          # Try to get the mapping for the specific branch
          eden_version=$(yq eval ".\"$BASE_REF\".eden_version" "$MAPPING_FILE")

          # If no specific mapping exists, use the default
          if [[ "$eden_version" == "null" || -z "$eden_version" ]]; then
            echo "No specific mapping found for branch '$BASE_REF', using default"
            eden_version=$(yq eval '.default.eden_version' "$MAPPING_FILE")
          fi

          # Verify that we have valid values
          if [[ "$eden_version" == "null" || -z "$eden_version" ]]; then
            echo "::error::Failed to determine eden_version for branch '$BASE_REF'"
            exit 1
          fi

          echo "Selected Eden version: $eden_version"

          echo "eden_version=$eden_version" >> "$GITHUB_OUTPUT"


  tests:
    name: ${{ needs.context.outputs.eden_parent_job_title }}
    needs: [context, select_eden_version]
    if: needs.context.outputs.skip_run == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Eden tests via repository dispatch
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        env:
          EDEN_VERSION: ${{ needs.select_eden_version.outputs.eden_version }}
          EVE_IMAGE: "evebuild/pr:${{ needs.context.outputs.pr_id }}"
          EVE_ARTIFACT_NAME: "eve-${{ needs.context.outputs.hv }}-${{ needs.context.outputs.arch }}-${{ needs.context.outputs.platform }}"
          ARTIFACT_RUN_ID: ${{ needs.context.outputs.original_run_id }}
        with:
          script: |
            const [owner, repo] = 'lf-edge/eden'.split('/');
            const dispatchResponse = await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: 'test.yml',
              ref: process.env.EDEN_VERSION,
              inputs: {
              eve_image: process.env.EVE_IMAGE,
              eve_log_level: 'debug',
              eve_artifact_name: process.env.EVE_ARTIFACT_NAME,
              artifact_run_id: process.env.ARTIFACT_RUN_ID,
              eden_version: process.env.EDEN_VERSION
              }
            });

            // Wait briefly for the workflow run to be created
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Get the workflow run that was just triggered
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'test.yml',
              branch: process.env.EDEN_VERSION,
              per_page: 1
            });

            const triggeredRunId = runs.workflow_runs[0]?.id;
            if (triggeredRunId) {
              core.setOutput('eden_run_id', triggeredRunId);
              console.log(`Triggered Eden workflow run ID: ${triggeredRunId}`);
            } else {
              console.log('Warning: Could not retrieve triggered workflow run ID');
            }
            });

            // Wait for the Eden workflow to complete
            console.log('Waiting for Eden workflow to complete...');
            let workflowCompleted = false;
            let conclusion = null;
            const maxWaitTime = 4 * 60 * 60 * 1000; // 4 hours
            const pollInterval = 30000; // 30 seconds
            const startTime = Date.now();

            while (!workflowCompleted && (Date.now() - startTime) < maxWaitTime) {
              const { data: run } = await github.rest.actions.getWorkflowRun({
              owner,
              repo,
              run_id: triggeredRunId
              });

              if (run.status === 'completed') {
              workflowCompleted = true;
              conclusion = run.conclusion;
              console.log(`Eden workflow completed with conclusion: ${conclusion}`);
              } else {
              console.log(`Eden workflow status: ${run.status}, waiting...`);
              await new Promise(resolve => setTimeout(resolve, pollInterval));
              }
            }

            if (!workflowCompleted) {
              core.setFailed('Eden workflow did not complete within the timeout period');
            } else if (conclusion !== 'success') {
              core.setFailed(`Eden workflow completed with conclusion: ${conclusion}`);
            }

            core.setOutput('eden_conclusion', conclusion);

  finalize:
    name: Finalize Eden Runner status
    if: always() && needs.context.outputs.skip_run == 'false'
    needs: [context, tests]
    runs-on: ubuntu-latest
    steps:
      - name: Update commit status
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        env:
          SHA: ${{ needs.context.outputs.pr_sha }}
          RESULT: ${{ needs.tests.result }}    # success / failure / cancelled
          EDEN_IN_PR_STATUS_TITLE: ${{ needs.context.outputs.eden_in_pr_status_title }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const map = { success:'success', failure:'failure', cancelled:'error' };
            const state = map[process.env.RESULT] || 'error';
            await github.rest.repos.createCommitStatus({
              owner, repo,
              sha: process.env.SHA,
              state,
              context: process.env.EDEN_IN_PR_STATUS_TITLE,
              description: `Eden tests ${state}`,
              target_url: `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            });

  subjob_statuses:
    name: Render each Eden jobs status
    if: always() && needs.context.outputs.skip_run == 'false'
    needs: [context, tests]   # ensure Eden has finished
    runs-on: ubuntu-latest
    steps:
      - name: Surface each Eden job as PR status
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        env:
          SHA: ${{ needs.context.outputs.pr_sha }}
          EDEN_PARENT_JOB_TITLE: ${{ needs.context.outputs.eden_parent_job_title }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const runId      = process.env.GITHUB_RUN_ID;
            const parentName = process.env.EDEN_PARENT_JOB_TITLE;
            const prefix     = `${parentName} / `;

            const { data } = await github.rest.actions.listJobsForWorkflowRun({
              owner, repo, run_id: runId, per_page: 100
            });

            for (const job of data.jobs) {
              // child jobs only
              if (!job.name.startsWith(prefix)) continue;

              // Filter out "Determine best available runner" postfix jobs
              if (job.name.includes('Determine best available runner')) continue;

              const state = job.conclusion === 'success'
                              ? 'success'
                              : job.conclusion === 'failure' ? 'failure'
                              : 'error';

              await github.rest.repos.createCommitStatus({
                owner, repo,
                sha: process.env.SHA,
                context: `${job.name}`,
                state: state,
                target_url: job.html_url,
                description:`${state}`
              });
            }
